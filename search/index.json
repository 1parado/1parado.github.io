[{"content":"\r2025-10-30 参考链接： JVM\nJava内存 ","date":"2025-10-30T00:00:00Z","permalink":"https://1parado.github.io/p/jvm-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"JVM 常见面试题"},{"content":"2025-10-26 Maven 参考：maven\n项目中依赖的第三方库以及插件可统称为构件。每一个构件都可以使用 Maven 坐标唯一标识.\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;easyexcel\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; maven仓库\n如果使用 Maven 构建产生的构件（例如 Jar 文件）被其他的项目引用，那么该构件就是其他项目的依赖。\n依赖传递: 遵循路径最短优先 和 声明顺序优先两大原则\nMaven本地仓库${user.home}/.m2/repository Maven远程仓库 官方维护的Maven仓库\nMaven 的生命周期就是为了对所有的构建过程进行抽象和统一。包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤 分为default clean site\nMaven插件\n一个Maven项目中不止有一个pom.xml文件 以此来实现多模块管理 多模块管理的好处：1.降低代码之间的耦合性 2.减少重复，提升复用性；3.每个模块都可以是自解释的；4.模块规范了代码边界的划分。 多模块管理下，会有一个父模块，其他的都是子模块。父模块通常只有一个 pom.xml，没有其他内容。父模块的 pom.xml 一般只定义了各个依赖的版本号、包含哪些子模块以及插件有哪些。\nGit 版本控制：本地版本控制，就是将文件复制一份修改名称。后来发展为集中化的版本控制，类似于主从节点，由主节点保存所有的修订版本，从节点连接到服务器进行拉取或提交。为了解决主节点单点故障的问题，发明了分布式版本控制，Git即分布式版本控制。 客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。\nGit的三种状态： 已提交commit 已修改 modified 已暂存 staged Git的三个工作区域：工作目录，暂存区域，Git 仓库目录\n过程：1.在工作目录中修改文件。 2.暂存文件，将文件的快照放入暂存区域。 3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。\nGit常用命令： 将GitHub或者Gitee等开源代码托管网站上面的项目拉取下来 只需要创建文件夹 在文件夹下打开cmd输入： git clone https://github.com/1parado/仓库名.git即可 将项目推到GitHub上： git命令 在编程工具IDEA，VScode等软件中都有版本控制 使用起来很方便，甚至Obsidian，Notion等笔记软件也可以用Git实现版本控制 就很舒服 需要注意的一点就是涉及隐私的文件不要发布在网上 可以在.gitignore声明\n","date":"2025-10-26T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7git-maven/","title":"常用工具Git Maven"},{"content":"\r参考：如何从零开始手写一个Redis\n2025.10.24 如何实现固定缓存大小 HashMap，ConcurrentHashMap可以作为缓存使用 但HashMap本身不是线程安全的 但是作为基础的Java集合 不管是HashMap还是ConcurrentHashMap本身不具备自动的数据淘汰机制，这样可能会导致OOM（内存溢出）\n淘汰机制：FIFO（先进缓存先被淘汰）,LRU（最近最少使用）,LFU（最近最少频率使用），从左往右命中率越来越高，成本也越来越高\n对于加了淘汰机制的HashMap仍然存在几个问题：锁竞争激烈，不支持过期时间，不知此自动刷新，于是出现了Guava Caffeine\u0026hellip;\n引导类：是指在框架或应用程序中负责启动和初始化的核心类。Springboot中引导类即Application为后缀的类 对于该项目 配置了一个缓存引导类CacheBS方便用户使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Test public void helloTest() { ICache\u0026lt;String, String\u0026gt; cache = CacheBs.\u0026lt;String,String\u0026gt;newInstance() .size(2) .build(); cache.put(\u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;); cache.put(\u0026#34;2\u0026#34;, \u0026#34;2\u0026#34;); cache.put(\u0026#34;3\u0026#34;, \u0026#34;3\u0026#34;); // 1从缓存中出来 3进去 cache.put(\u0026#34;4\u0026#34;, \u0026#34;4\u0026#34;); // 2从缓存中出来 4进去 Assert.assertEquals(2, cache.size()); // 测试cache的大小是否为2 不相同则测试不通过 System.out.println(cache.keySet()); } 实现过期时间expire Redis中的expire可以用于验证码失效，登录token失效等业务场景\u0026hellip; 设计一个cacheExpire接口 可以计算多久之后过期\n过期的实现原理：可以通过一个定时任务比如一秒钟一次轮询，一次清理10个数据，直到将过期的信息清空。可以将过期数据存入到map中 key对应过期的数据 value对应过期时间。在这里定义了一个单线程 用来执行清空任务，清空任务执行的过程即遍历map中的key 判断value是否过期，为了避免单词执行时间太久 所以设置一个单次清空最大数量限制。\n定时任务优化：可以通过排序Map快速判断哪些过期数据需要清理，即让过期时间作为key，让相同过期时间的数据放入列表中作为value。\n由于我们采用了定时轮询的方式 所以有时候数据可能清理不及时 当访问数据的时候可能访问到脏数据。因此引入了惰性删除，当用到某个数据的时候 才对数据进行删除判断操作。\n具体实现：在用到某些数据之前 先对数据进行刷新操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Test public void expireTest() throws InterruptedException { ICache\u0026lt;String, String\u0026gt; cache = CacheBs.\u0026lt;String,String\u0026gt;newInstance() .size(3) .build(); cache.put(\u0026#34;1\u0026#34;, \u0026#34;1\u0026#34;); cache.put(\u0026#34;2\u0026#34;, \u0026#34;2\u0026#34;); long now = System.currentTimeMillis(); cache.expireAt(\u0026#34;1\u0026#34;, now+40); Assert.assertEquals(2, cache.size()); // 沉睡 50S，让其过期 TimeUnit.MILLISECONDS.sleep(50); Assert.assertEquals(1, cache.size()); System.out.println(cache.keySet()); } expire过期如何随机获取key 之前实现的过期很简单 用hashMap存储过期数据，然后轮询处理，执行定时清理任务 redis实现的定时清理任务并不是时时刻刻都在执行的，定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例、使用快慢两种速率模式回收键，如图所示，先随机抽取key 如果有四分之一以上的key过期则执行 否则不执行\n实现内存数据重启不丢失 由于我们的数据是放在内存中的 如何保证重启之后数据还在？（Redis持久化）\nRedis的持久化机制包括三种：RDB(快照)，AOF（只追加文件），混合策略.\n这里我们先实现RDB快照模式，我们可以在缓存启动的时候，可以通过指定初始化加载的信息，从而实现数据持久化。现在我们需要知道如何将缓存中的内容持久化到文件或数据库中？，知道这些信息，就可以在重启之后加载这些信息，来保证数据不丢失了。对于导出的文件来说还有很多细节，比如文件的压缩，CRC校验\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 @Test public void persistRdbTest() throws InterruptedException { ICache\u0026lt;String, String\u0026gt; cache = CacheBs.\u0026lt;String,String\u0026gt;newInstance() .load(new MyCacheLoad()) // 指定持久化策略 .persist(CachePersists.\u0026lt;String, String\u0026gt;dbJson(\u0026#34;1.rdb\u0026#34;)) // 传入文件 .build(); Assert.assertEquals(2, cache.size()); TimeUnit.SECONDS.sleep(2); } AOF模式：RDB模式将缓存内容全部持久化比较耗时， AOF模式针对修改内容的指令，将指令顺序添加到文件中，因此AOF的实时性更好，顺序写避免了IO的随机写问题。\n添加监听器 删除监听器：我们之前已经实现expire 是对用户透明的（用户感知不到），并且当内存满了的时候，Redis会进行内存淘汰（evict 淘汰），这对用户来说也是透明的 如果用户想获取到这些信息，可以通过添加监听器实现。即在删除的位置调用监听器即可。\n慢操作监听器：redis 中会存储慢操作的相关日志信息（参数包括：耗时阈值，最多存储多少条慢日志记录） 所有我们可以对于所有的操作记录操作耗时 如果耗时超过用户设置的阈值 调用慢操作监听器\n自定义监听器\u0026hellip;\n2025.10.26 LRU 缓存淘汰 LRU最近最少使用 是一种比较常见的淘汰算法 如果数据最近被访问过 就认为被访问的概率更高\n局部性准则：时间局部性（最近被访问过，再次访问的肯可能性很高）和空间局部性（访问到某个磁盘信息，接下来可能访问局部的存储空间）缓存中用到的LRU即遵循了时间局部性准则\n实现：利用链表 新数据插入到链表头部 缓存命中，将命中数据移到链表头部 如果链表满了丢弃链表尾部数据。 代码实现起来需要用到：链表插入，如何判断缓存命中（HashMap），链表删除等知识\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void lruEvictTest() throws InterruptedException { ICache\u0026lt;String, String\u0026gt; cache = CacheBs.\u0026lt;String,String\u0026gt;newInstance() .size(3) .evict(CacheEvicts.\u0026lt;String, String\u0026gt;lru()) .build(); cache.put(\u0026#34;A\u0026#34;, \u0026#34;hello\u0026#34;); cache.put(\u0026#34;B\u0026#34;, \u0026#34;world\u0026#34;); cache.put(\u0026#34;C\u0026#34;, \u0026#34;FIFO\u0026#34;); // 访问一次A // cache.get(\u0026#34;A\u0026#34;); cache.put(\u0026#34;D\u0026#34;, \u0026#34;LRU\u0026#34;); Assert.assertEquals(3, cache.size()); System.out.println(cache.keySet()); } 如果是FIFO 结果应该是[B,C,D] 由于是LRU A最近被访问过 所以淘汰的是B 结果是[A,C,D] LRU 缓存淘汰优化 优化思路：1.用一个数组存储时间戳 为每个数据添加一个时间戳属性 每次访问数据时，更新该数据的时间戳 当数据空间满的时候 扫描时间戳最小的数据 但是需要用空间存储时间戳 并且淘汰数据的时候需要扫描整个数组\n2.之前的简单实现是基于链表的 由于链表的性质（链表中插入和删除某个已知元素的时间复杂度是O(1)，但是插入和删除之前需要遍历链表找到元素时间复杂度是O(N)）因此可以用双向链表优化一下淘汰末尾数据的操作\n3.双向链表查找某个元素依然需要遍历链表 时间复杂度是O(n) 可以基于双向链表和哈希表 将哈希表中的数据和链表中的节点形成映射 插入和删除操作的时间复杂度下降为O(1) 但是引入哈希表会造成空间开销\nLinkedHashMap是一种list和HashMap结合的数据结构 但是LinkedHashMap不会淘汰数据 可以重写removeEldestEntry方法实现淘汰数据。\nLRU 缓存淘汰算法如何避免缓存污染 当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。\n1.LRU-K算法:LRU是将最近使用一次的数据放入缓存 LRU-K是通过维护一个队列，用于记录缓存数据被访问的历史 当某个数据的访问次数达到K时 将数据放入缓存 数据淘汰的时候淘汰第K次访问时间距当前时间最大的数据 数据第一次被访问时，加入到历史访问列表，如果数据在访问历史列表中没有达到K次访问，则按照一定的规则（FIFO,LRU）淘汰；\n当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列中删除，将数据移到缓存队列中，并缓存数据，缓存队列重新按照时间排序；\n缓存数据队列中被再次访问后，重新排序，需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即“淘汰倒数K次访问离现在最久的数据”。\n2.2Q算法 将LRU-2中的历史访问列表改为FIFO缓存队列 因此2Q算法中有两个缓存队列：FIFO队列和 LRU队列\n3.MQ算法 根据数据的访问频率将数据分为多个队列 不同的队列有不同的访问优先级 优先缓存访问次数最多的数据。\n最近最不常用（LFU）淘汰算法 LFU将频率上最不常访问的数据淘汰 需要额外存储每个数据的访问次数\n如果用HashMap将key放数据，value放访问次数的话 新增和查询的时间复杂度都是O(1),但是删除就需要遍历HashMap时间复杂度为O（n）。在此基础上，用小顶堆+HashMap 插入和删除的操作是O（logn）。如果在淘汰数据的时候想要实现O(1)的时间复杂度，可以利用双Hashmap，HashMap中存放 key 和节点之间的映射关系，节点中的value保存对应的访问次数信息 相同的访问次数同freqMap进行关联 可以通过频率获取响应的链表\n基于上面两种淘汰策略可以看到LFU是基于访问频次的模式，而LRU是基于访问时间的模式。\nClock 页面置换算法 操作系统使用的内存管理即Clock页面置换算法，该算法通过链接指针将内存中的所有页面组织成一个循环队列，并为每个页面设置一个访问位。当页面被访问时，其访问位设置为1。当需要淘汰页面以释放空间时，算法会扫描循环队列，选择访问位为0的页面进行置换。如果所有页面的访问位均为1，则将它们置为0并进行第二轮扫描。\n实现：循环链表 + map 改进后的Clock页面置换算法：除了访问位，添加一个修改位 考虑了页面是否被修改过 优先淘汰未被修改过的页面\n分布式锁 Jdk中提供了加锁方式：synchronized加锁，乐观锁，读写锁，可重入锁\u0026hellip;在单机系统中为多线程情况下保证线程安全。在分布式系统中，上面的锁不再适用，因此为了解决分布式系统中的并发问题 需要引入分布式锁。 参考：分布式锁原理\n分布式锁：是一种跨节点，跨服务的互斥机制，一个可靠的分布式锁需要满足：互斥性，安全性，防死锁，可用性，容错性。 实现的核心原理：通过SET命令实现互斥 即用一个redis键作为锁的标识 当客户端对某个共享资源获取锁时，需要判断该资源是否已上锁 没上锁的时候才可以设置锁键获取锁，释放锁的时候删除锁键即可（在释放锁的时候可以通过Lua脚本实现操作的原子性）。 SET命令的两个参数：NX（not exist） 用于获取锁 PX设置锁键的过期时间\n获取锁的命令比如：SET lock:stock client1 NX PX 30000\nHashMap源码 HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。HashMap实例有两个影响其性能的参数: 初始容量（16）和负载因子（默认0.75），阈值可以通过threshold = length * Load factor计算。HashMap非线程安全\n参考：hashmap源码分析\nHashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组。\n哈希桶是一种通过链地址法（开散列法）解决哈希冲突的结构。它将具有相同散列地址的元素存储在一个链表中，每个链表被称为一个哈希桶.\nHashMap是使用哈希表存储的 哈希表为了解决哈希冲突 可以采用开放地址法和链地址法，HashMap采用了链地址法。为了控制hash冲突发生的概率且让哈希桶数组的占用空间少，于是需要一个好的Hash算法和扩容机制。\n扩容机制：Node[] table(哈希桶数组)，初始化长度为16，负载因子为0.75，阈值为初始化长度 * 负载因子。当数量超过阈值时需要扩容，扩容之后HashMap容量是之前的2倍。在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这种设计主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。在JDK1.8中，引入了红黑树，当链表长度过大（超过8），链表转化为红黑树。因为红黑树的查找时间复杂度为O(logn) 链表查找的时间复杂度为O(n).Java中的数组不会自动扩容，实际上是通过一个新的数组代替原有的数组，通过resize方法实现。在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。\n","date":"2025-10-24T00:00:00Z","permalink":"https://1parado.github.io/p/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAredis/","title":"手写一个Redis"},{"content":"\r首先需要了解一下什么是ORM（对象关系映射）:简单来说就是在关系型数据库和对象（Bean，Entity）之间作一个映射，通过这种映射 我们就可以用面向对象编程（OOP）概念喝语法来操作数据库 不需要直接写SQL语句 ORM设计可以实现数据存取与业务逻辑完全分离 Java中现在主流的ORM框架包括：\n1.Hibernate：最流行的Java ORM框架之一\n2.MyBatis：一种\u0026quot;半自动\u0026quot;的ORM框架\n3.MyBatis-plus：MyBatis增强版 自带 CRUD、分页、Wrapper 等\nMyBatis和Hibernate的区别可以看这篇文章：MyBatis和Hibernate到底哪个好\n本文使用的是Hibernate框架 因为他是spring默认的ORM框架 且支持快速开发 实现起来比较方便 而且我现在实现的只是一些简单的增删改查 数据量也不是很大 所以选用Hinernate框架\n在pom文件中添加下面依赖 即可使用\n1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Hibernate有两种映射方法 一种是基于xml文件进行映射 一种是基于注解映射 配置方法1 ：在hibernate.cfg.xml文件中配置数据库和映射文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE hibernate-configuration PUBLIC \u0026#34;-//Hibernate/Hibernate Configuration DTD 3.0//EN\u0026#34; \u0026#34;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\u0026#34;\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;!-- 数据库连接配置 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.driver_class\u0026#34;\u0026gt;com.mysql.cj.jdbc.Driver\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.url\u0026#34;\u0026gt;jdbc:mysql://localhost:3306/数据库名\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.username\u0026#34;\u0026gt;账号\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.password\u0026#34;\u0026gt;密码\u0026lt;/property\u0026gt; \u0026lt;!-- SQL方言 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.dialect\u0026#34;\u0026gt;org.hibernate.dialect.MySQL8Dialect\u0026lt;/property\u0026gt; \u0026lt;!-- 显示SQL语句 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.show_sql\u0026#34;\u0026gt;true\u0026lt;/property\u0026gt; \u0026lt;!-- 自动创建表 --\u0026gt; \u0026lt;property name=\u0026#34;hibernate.hbm2ddl.auto\u0026#34;\u0026gt;update\u0026lt;/property\u0026gt; \u0026lt;!-- 映射文件 --\u0026gt; \u0026lt;mapping resource=\u0026#34;com/example/model/User.hbm.xml\u0026#34;/\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt; 配置方法2：即在yml文件中配置：然后在实体类上用注解的方式实现映射\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 spring: datasource: url: jdbc:mysql://localhost:3306/mydb username: root password: password driver-class-name: com.mysql.cj.jdbc.Driver jpa: hibernate: ddl-auto: update show-sql: true properties: hibernate: dialect: org.hibernate.dialect.MySQL8Dialect 在entity包创建实体 Hibernate可以通过实体类自动生成表结构 参考Hibernate的执行过程，简单说明一下Hibernate的执行过程\n创建configuration实例，加载配置文件和映射文件到实例中\u0026ndash;创建sessionFactory实例\u0026ndash;创建session实例（非线程安全，每次请求创建一个新实例）\u0026ndash;创建Transaction实例开启事务\u0026ndash;利用session接口进行持久化操作\u0026ndash;提交事务\u0026ndash;关闭session和sessionFactory断开连接\n项目的实现过程：首先前端有两个按钮 测试连接和执行查询 前端将请求发送给后端 点击测试连接来测试是否连接到数据库 点击执行按钮会将输入的文本传入后端 后端通过调用本地大模型将其转换为SQL语句 并且执行SQL操作 实现自然语言操作数据库的功能\n遇到的问题1：后端端口在8080 前端端口在63342 浏览器默认阻止不同源之间的请求 所以需要CORS配置（跨域资源共享） 在WebConfig文件中加入下面代码实现跨域资源共享\n1 2 3 4 5 6 7 8 9 10 11 //配置全局CORS @Configuration public class WebConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { registry.addMapping(\u0026#34;/api/**\u0026#34;) .allowedOrigins(\u0026#34;http://localhost:63342\u0026#34;) // 根据实际前端端口调整 .allowedMethods(\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;DELETE\u0026#34;) .allowCredentials(true); } } 遇到的问题2：调用的本地模型是qwen2:0.5b 他太逊了（其实是我prompt没给对）刚开始一直不能将文本语言转为正确的SQL语句 后面换了几次prompt才能正常运行。\n运行页面： 第一次查询失败 因为我犯蠢了 没将ollama启动\n用英文操作其实也是阔以的 因为输入的文本都是传入给本地大模型了 他会给你正确的sql语句 正确的操作数据库\n现在这个系统只是实现了查询功能 其他增删改操作实现起来跟查询操作大同小异 所以通过自然语言操作数据库是可行的并且有益于降低数据操作的门槛 GitHub上有好多优秀的开源项目 这里我就不一一列举了 总之 这个系统只是一个简单的MCP数据库的基本实现。\n项目源码地址：https://github.com/1parado/MCP-Database\n","date":"2025-10-23T00:00:00Z","permalink":"https://1parado.github.io/p/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E8%BD%ACsql%E8%AF%AD%E5%8F%A5%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C/","title":"自然语言转SQL语句实现增删改查操作"},{"content":"\r实现过程：1.创建机器学习模型 通过（朴素贝叶斯 + TF-IDF 向量化）实现文本二分类 当文本中包含敏感词的时候返回1 否则返回0 这里我创建了一个sensitive_detector.py文件。首先自定义输入一些敏感词数据库，然后进行文本向量化，将文字转为数值特征，然后用MultinomialNB模型进行训练 最后保存模型（.pkl文件），让该模型运行在本地的一个端口上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from flask import Flask, request, jsonify from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB import jieba import joblib app = Flask ( __name__ ) # === 1. 准备数据 === texts = [ # 正常内容 \u0026#34;我爱学习人工智能\u0026#34;, \u0026#34;今天真开心\u0026#34;, \u0026#34;你好，朋友\u0026#34;, \u0026#34;祝你生活愉快\u0026#34;, \u0026#34;我喜欢听音乐\u0026#34;, \u0026#34;看电影真有趣\u0026#34;, \u0026#34;一起打游戏吧\u0026#34;, \u0026#34;美丽的风景让人心情愉快\u0026#34;, # 敏感内容 \u0026#34;买枪支弹药请加我\u0026#34;, \u0026#34;出售身份证\u0026#34;, \u0026#34;这是黄色网站链接\u0026#34;, \u0026#34;成人内容免费看\u0026#34;, \u0026#34;黄色小说推荐\u0026#34;, \u0026#34;如何制作炸弹\u0026#34;, \u0026#34;赌博网站登录入口\u0026#34;, \u0026#34;免费看黄片\u0026#34; ] labels = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1] # 0=正常，1=敏感 # === 2. 中文分词函数 === def chinese_tokenizer(text): return jieba.lcut ( text ) # === 3. 向量化 + 训练模型 === vectorizer = TfidfVectorizer ( tokenizer=chinese_tokenizer ) X = vectorizer.fit_transform ( texts ) model = MultinomialNB () model.fit ( X, labels ) # === 4. 保存模型（方便部署） === joblib.dump ( vectorizer, \u0026#39;vectorizer.pkl\u0026#39; ) joblib.dump ( model, \u0026#39;model.pkl\u0026#39; ) @app.route ( \u0026#34;/predict\u0026#34;, methods=[\u0026#34;POST\u0026#34;] ) def predict(): data = request.get_json () text = data.get ( \u0026#34;text\u0026#34;, \u0026#34;\u0026#34; ) X_new = vectorizer.transform ( [text] ) pred = model.predict ( X_new )[0] return jsonify ( {\u0026#34;sensitive\u0026#34;: bool ( pred )} ) if __name__ == \u0026#34;__main__\u0026#34;: app.run ( port=5001 ) 运行上述py文件：\n接下来可以通过postman等接口测试工具测试一下，当发布敏感词的时候会显示true 无敏感词的时候显示false。\n运行项目进行检测：\n到此 就实现了一个简单的文本敏感词检测功能 可以用于论坛模块的发帖和评论功能中。后续可以扩展敏感词库，敏感词库可以从开源中文敏感词库（如“百度敏感词库”、“naughty-words 中文版”）获取\u0026hellip;\n","date":"2025-10-22T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A3%80%E6%B5%8B/","title":"如何实现一个简单的敏感词检测"},{"content":"\r对于某些需要隐私保护的文件或者内容不太适合用在线翻译软件，因此可以在自己电脑上实现一个翻译器\n首先看一下百度翻译的页面包括好多功能，文本翻译，图片翻译\u0026hellip; 今天先简单实现一下文本翻译 对于一个翻译系统其实很简单 只要前端点击翻译按钮 后端能返回响应结果即可 关键在于如何返回正确的结果 这里我先创建了一个翻译器V1 用于测试前后端联动是否可以打通\n如果想要识别语言并且返回正确结果 可以有两种方法 一种是调用厂家的API 一种是调用大模型，提供prompt让大模型当你的翻译官即可\n可以在百度翻译开放平台获取API和密钥\n可以在TranslationService中调用API实现调用接口进行翻译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package com.example.translation.service; import org.springframework.stereotype.Service; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.util.UUID; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; @Service public class TranslationService { // 替换为你自己的百度翻译 AppID 和密钥 private static final String APP_ID = \u0026#34;你的AppID\u0026#34;; private static final String SECURITY_KEY = \u0026#34;你的密钥\u0026#34;; public String translate(String text, String targetLang) { try { String from = \u0026#34;auto\u0026#34;; String to = getBaiduLangCode(targetLang); String salt = UUID.randomUUID().toString(); String sign = md5(APP_ID + text + salt + SECURITY_KEY); String encodedText = URLEncoder.encode(text, StandardCharsets.UTF_8); String urlStr = String.format( \u0026#34;https://fanyi-api.baidu.com/api/trans/vip/translate?q=%s\u0026amp;from=%s\u0026amp;to=%s\u0026amp;appid=%s\u0026amp;salt=%s\u0026amp;sign=%s\u0026#34;, encodedText, from, to, APP_ID, salt, sign); URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\u0026#34;GET\u0026#34;); conn.connect(); BufferedReader reader = new BufferedReader( new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8)); StringBuilder result = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { result.append(line); } reader.close(); conn.disconnect(); // 简单解析返回内容 String res = result.toString(); int start = res.indexOf(\u0026#34;\\\u0026#34;dst\\\u0026#34;:\\\u0026#34;\u0026#34;); if (start \u0026gt; 0) { int end = res.indexOf(\u0026#34;\\\u0026#34;}\u0026#34;, start); return res.substring(start + 7, end).replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;).replace(\u0026#34;\\\\u\u0026#34;, \u0026#34;u\u0026#34;); } return \u0026#34;翻译失败：\u0026#34; + res; } catch (Exception e) { e.printStackTrace(); return \u0026#34;翻译错误：\u0026#34; + e.getMessage(); } } private String getBaiduLangCode(String target) { return switch (target.toLowerCase()) { case \u0026#34;english\u0026#34; -\u0026gt; \u0026#34;en\u0026#34;; case \u0026#34;japanese\u0026#34; -\u0026gt; \u0026#34;jp\u0026#34;; case \u0026#34;korean\u0026#34; -\u0026gt; \u0026#34;kor\u0026#34;; case \u0026#34;french\u0026#34; -\u0026gt; \u0026#34;fra\u0026#34;; case \u0026#34;german\u0026#34; -\u0026gt; \u0026#34;de\u0026#34;; default -\u0026gt; \u0026#34;en\u0026#34;; }; } private String md5(String input) throws Exception { MessageDigest md = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;); byte[] array = md.digest(input.getBytes(StandardCharsets.UTF_8)); StringBuilder sb = new StringBuilder(); for (byte b : array) { sb.append(String.format(\u0026#34;%02x\u0026#34;, b \u0026amp; 0xff)); } return sb.toString(); } } 由于我电脑上面下载的有Ollama 所以我选择调用本地大模型的接口服务 实现翻译功能 不知道的同学可以下载一下ollama 然后下载一个模型 建议qwen:0.5b 即可 其他模型占用内存太大 输入ollama list 看一下本地已经下载了哪些模型 打开Windows终端 输入命令 ollama run qwen2:0.5b\n给模型设置提示词然后让后端服务调用本地大模型即可实现翻译功能\n1 2 3 Map\u0026lt;String, Object\u0026gt; body = new HashMap\u0026lt;\u0026gt;(); body.put(\u0026#34;model\u0026#34;, \u0026#34;qwen2:0.5b\u0026#34;); body.put(\u0026#34;prompt\u0026#34;, \u0026#34;请将以下文本翻译成英文：\u0026#34; + text); 接下来启动服务 看一下效果 遇到的问题：在运行的时候 我的8080端口号被占用了 可以换一个端口号 也可以将启动的服务关闭 这里我选择关闭现有服务 然后重新启动 监听8080端口\n","date":"2025-10-22T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BF%BB%E8%AF%91%E5%99%A8/","title":"实现一个本地翻译器"},{"content":"\r2025.10.20 今天是去实习的第一天 新手上班感觉憋不住笑啊（摸鱼的一天） 王哥给我两个压缩包文件让我先看懂公司代码的逻辑是怎么写的 确实到了公司才知道还有好多东西不知道的 纸上学来终觉浅 今天我甚至手忙脚乱到sql脚本都不知道在哪里执行了\u0026hellip; 明天估计要开始慢慢干活了吧 要写一个任务管理模块 王哥说今晚他把数据库和脚手架创建好 明天我可以先自己尝试了 我觉得还挺好的吧 这个实习 而且合同上面签的也是学生出去学习为主 学校有事情 提前七天告知公司就可以了 Nice！ 今天学到的东西：1.sql脚本执行 2.cmd中输ifconfig查看本机ip 3.关闭快速开机能减少运行内存的使用 附图两张： 2025.10.21 实习第二天 又看了一下自己简历上面的项目 在想一下是不是还能加一下其他模块 显得比较高科技 但是现在已经有了AI聊天机器人了 一直想做个代码生成器 但是发现已经有现成的了 不知道还能加什么模块？？？ 今天中午午休的时候做力扣 链表的知识我都忘记了！这狗算法咋这么难？？？？？？？？？？？？？？？？？？？？？ 附图两张：这太阳看起来美 但是刺眼睛 果然我还是从浪漫主义变成了实用主义（doge） 2025.10.22 实习第三天 拿到数据库 本来想着做一下的 但是水平还不太够 我得再摸索几天 看看公司代码都是怎么写的 应该挺好写的 比较难的业务估计也不会让我们实习生做 但是在这还是可以学到东西的。今天早上来的太早了 八点就到了 第一个到的！ 入职第三天我才知道要用飞书进行上下班打卡 等我下载好之后竟然已经八点四十了 打卡居然迟到了 真搞笑0.0 附近的车咋都长得这么帅 慕了 算法回学校再看 依旧感叹 算法好难 我现在还是摸不着套路 这算法还是得先看课吗？？ 附图两张： 小may 祝你开心\n2025.10.23 实习第四天 依旧是早八人 明明要求八点半上班 我为什么每天八点就到公司了？天生打工人 但其实也还好 早点进入学习状态对我来说是件好事 我现在就是不想被学校的事情束缚 在公司能学到的东西挺多的 而且公司氛围真的很轻松了 今天午休时间刷算法也挺顺利的 换了种刷题的策略 不按照分类刷了 按照简单题 中等难度 困难题来刷 希望能进步的快一点！！！\n2025.10.24 今天是程序员节 依依依然是八点上班 我有点过于勤奋了 今天是周五 写这段话的时候已经晚上23.37分了 感觉前端UI做的差不多了 下周估计就能正式进入程序员的工作状态了 我发现我是不是对一些人带着偏见啊 听我发小分析完之后发现确实有点 这种先入为主的观念还是尽量不要 今天刷力扣大多都是树的题 我看了一下今天总共写了七道题吧 （都是简单题 不会的我都立马看题解了）希望这样刷题对我来说有帮助 对了今天往自己的项目添加了一个学生成就展示 主要还是前端代码没了解过 不太会写 可以之后再完善一下 之前王哥跟我说可以学全栈的 前端入门比较容易的 今天知道了一本好书《Effective Java》 泡泡告诉的。不想换另一篇博客 把今天是实现的功能就放在这吧。下周要交周报（学校和公司都要）我好命苦（/(ㄒoㄒ)/~~）晚安，May。\n2025.10.27 昨天睡了5h50min，早上又是八点到的工位上，今天不是第一个到的，第一个到的是公司的大boss，我发现个很有趣的现象 大boss不走 下午就没有人下班 所以我磨磨蹭蹭到了5.50（本来是5.30就下班的）才下班，我觉得公司的人都挺好的 今天把任务需求讲给我们实习生们听了 开始分配工作了 我觉得还是在公司学到的东西比较多一点 网上学的东西都是花拳绣腿 没办法落地应用 总之 我也是分配到了四个模块 公司的正式员工他们正在忙 所以基本上就是我和另一个实习生搭子一起琢磨 幸好他之前已经有了两三个月的开发经验了 教我还是绰绰有余的 等过两天上手了就简单了 还要特别感谢前端开发的张哥 下班了他加我微信（是我太不懂事了 竟然让人家主动加我微信）给我指导意见 感觉努力之后 碰到的都是贵人 一路上都是贵人相助 如果没有我哥在论文上指导我 我也不会这么快写出一篇论文（很水），如果没有YH介绍，我也没办法这么快来到公司实习 这一路上想要感谢很多人\u0026hellip; 而且今天认识了一个成都美团的实习生 希望寒假实习可以找他拿内推！！！ 团子，你等着我。加油加油！！！我的C盘只剩下30个G了 我用户文件夹占一百多个G ？ 2025.10.28 今天在公司写公司业务代码 所以没什么时间学习其他的 来公司学到的东西一个就是看自己的ip 一个就是如何用贝锐花生壳访问内网数据 公司项目用的是RuoYi 主要是代码版本太多了 数据库也是 总之我现在是一头雾水 本来应该阔以用代码生成器生成代码框架的 但是现在我得自己搭框架 但是也还好吧 至少能更熟悉项目怎么写的 在写的时候 我觉得最主要的还是和前端交互的问题 不知道该传回前端什么参数 所以我只能先自己写 等到时候测试的时候再改 听说之前他们也是这样做的 如果想自测的话就用postman 我现在就是如此 今天总算开始写功能模块了 周五要交公司周报 周四要在学校开组会汇报 有点累累的 但是！今天May给我个惊喜 她看我腰痛 给我买了个腰部按摩仪 好幸福 好感动 谢谢哦 公司的业务代码就不放了 今天实现的功能模块不多 希望之后熟悉之后写的快点 然后学习其他的 加油 爱你May. 附图两张： 2025.10.29 我天 真的好忙哇 今天甚至连算法都没做！！！今天差点以为迟到，但还是八点十分左右到了 今天一天都在和前端张哥对接接口 我本来打算自己从头开始写的 原来还是得AI写 cursor，trae轮流给我干活吧！ 其实现在已经10.30号的凌晨了 本来cursor用的好好的 但是白嫖太多次了 给我ban了 幸好方法总比困难多 有时间可以记录一下cursor如何白嫖 刚刚终于成功了 继续白嫖！下载了trae国际版 本来还以为用Claude 3.7免费的 还挺好 原来需要排队哦 甚至在执行过程中还需要排队 但是这个其实还好 首月3美刀 其实可以用用看的 今天晚上把分配给我的模块api文档都写好了 看情况是现在前端需要根据api接口文档先写代码 然后我们后端的再开始改我们的业务逻辑 我觉得我现在的代码依托shit 好多逻辑都对不上 主打一个能跑起来就行 希望学校和公司早点发钱！！！！ 不想总说之后之后了。学校这边明天下午还要开组会 还要写周报（导师最新要求的） 公司那边也要周报 我天 我是超人吗？ 我还要学算法 背八股 写自己的项目 这时间掰成几份都不够用哦 我和may打电话的时间都被占用了 等过了这段时间 看看会不会好一点 晚安 May。\n2025.10.30 今天下午有组会 所以下午请了假 室友的同门也想来公司上班 所以我问了一个HR姐 她说请示一下大老板 今天组会的时候 老师说开题没有要求 毕业也没有要求 只是最后发的论文 如果发的期刊太水了 老师不报销 其实这样也还好 对于想找工作的 出去找实习经历 顺便也把发期刊的钱挣了 对于想读博深造的人 在学校跟随老师的步伐继续写好论文 这样其实挺好的 我很支持 希望之后能顺利毕业 我是觉得我这篇论文发EI没问题 到时候看看吧 希望没问题 自从决定学习技术找工作之后 我就一直挺焦虑的 没办法平衡好工作和生活 有时候甚至觉得放假休息都不行 一周七天 每天都在高强度的学习 锻炼时间也减少了 我觉得这样肯定不适合长久发展 身体熬垮了 再好的短期收益也不值 很谢谢May给我买点按摩仪哦 很好用 谢谢 也很感谢家里面给我生活费 父母的爱真的无以为报 希望我以后能挣大钱！！！ 但是我本质上对钱也没啥想法 公司的任务还是很多的 早上的时候依然在测试 不知道这个项目要做到什么时候 今天写了几道算法题 写算法真的很影响心情 而且很耗费精力 害的我都没办法好好陪May 🐕力扣 真的好想有个好工作啊 祝我好运 明天周五了 又可以过双休了 时间过的好快 希望十二月之后 一月份左右 我能找到去成都的实习 希望是团子！ 加油！！！\n","date":"2025-10-20T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/","title":"实习经历"},{"content":"\r2025-10-19 参考链接： https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis\nRedis是NoSQL数据库，是一种内存数据库。读写速度很快，经常用于分布式缓存方向，存储的是key-value对数据。Redis支持事务，持久化，lua脚本\u0026hellip;\n可以试一下在线编译器写一下redis命令 简单易上手 easy~\nRedis为什么速度快：1.纯内存操作（纳秒级），传统的数据库需要读写磁盘（毫秒级） 2.高效的I/O模型。3.优化的内部数据结构4.简洁高效的通信协议（RESP）. redis适合做缓存不适合做主数据库，因为内存成本高，且redis虽然支持数据持久化但是有数据丢失风险。 其他的分布式缓存：Tendis,KeyDB\u0026hellip;\n选择Redis的原因：1.访问速度快（基于内存） 2.高并发 3. 功能全面（可以作缓存，可以用于分布式锁，限流，消息队列，延时队列\u0026hellip;）\n常见的缓存读写策略：https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html\n2025-10-20 Redis 应用\n缓存 分布式锁 Redission 做限流工具 Redis+LUA脚本 RRateLimiter实现分布式限流即基于Lua脚本+令牌桶算法 做消息队列 Redis的Stream类型的数据结构更适合做消息队列（但一般用中间件） 做延时队列 内置了延时队列 基于Sorted Set实现 分布式session 利用String或Hash数据结构存储session数据 Redis可以实现全文搜索引擎功能 需要借助RedisSearch（一个基于Redis的搜索引擎模块）：性能更优秀 较低内存占用实现快速索引。\n延时任务（红包过期自动退还）:实现方式：1. redis过期事件监听（不推荐） 2. redission内置的延时队列 减少了丢消息的可能，消息不存在重复消费问题\nredis常见的数据类型：String、List、Set、ZSet、Hash 三种特殊数据类型：HyperLogLog（基数统计）、Bitmap （位图）、Geospatial (地理位置)\n2025-10-21 Redis持久化机制： redis支持三种持久化： 1.快照RDB，2.只追加文件AOF， 3.RDB和AOF混合持久化\n1.RDB持久化 创建快照获取存储在内存种数据在某个时间点的副本 创建快照之后 可以对快照备份 可以创建副本（Redis主从结构） RDB是redis默认的持久化方式\nRDB创建快照 save：同步保存操作 会阻塞Redis主线程 bgsave 用子进程执行 不会阻塞Redis主线程\n2.AOF持久化 实时性更好 开启AOF持久化之后每次执行改变redis数据的命令 redis就会将该命令写入AOF缓冲区 然后再写入到AOF文件\nAOF流程：所有的写命令追加到AOF缓冲区 文件写入：将AOF缓冲区的数据写入到AOF文件中 文件同步： AOF缓冲区根据对应的持久化方式向硬盘做同步操作 文件重写：AOF越来越大 需要定期对AOF文件重写 重启加载：redis重启时 可以加载AOF文件进行数据恢复\nredis有三种不同的AOF持久化方式（区别在于同步AOF文件的时机不同 即刷盘时机不同）： 1.appendfsync always 2.appendfsync everyseconds 3.appendfsync no\n一般的关系型数据库是在执行命令前记录日志 AOF持久化机制是在执行命令之后记录日志：优点：可以避免额外开销 不会阻塞当前执行的命令 缺点：可能会造成修改丢失 可能会阻塞后续其他命令\nAOF重写（当AOF文件越来越大 进行AOF重写即压缩AOF文件） Redis将AOF重写程序放在子进程执行 避免造成对redis正常处理命令请求造成影响。\nRedis单线程模式和多线程模式：\n对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作，Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）\nRedis内存管理 保存的缓存数据会有一个过期时间 如果不设置过期时间 可能会出现OOM内存溢出问题 expire key 60 // 在60s后key过期 setex key 60 value // 数据在 60s 后过期（对于字符串类型） ttl key //查看数据还有多久过期 过期时间还可以用于业务场景中如登录token，验证码\u0026hellip;\nredis通过过期字典保存数据过期的时间，过期字典的key指向redis的某个key 过期字典的值指向key的过期时间 在查询key的时候 redis会首先检查一下key是否过期 即在过期字典中查找key是否存在 存在的话 进行过期删除\nredis过期删除策略包括： 惰性删除（取出key时进行检查），定期删除（周期性的抽查一些key），延迟队列（将设置过期时间的key放入延迟队列 到期后删除key），定时删除（数据过期立马删除） Redis 采用的是定期删除+惰性删除结合的策略 由于定期删除是周期性的随机抽查一些数据，抽查的数据数量由expire.c决定 默认为20 定期删除的频率由hz决定 默认为10 表示每秒执行10次尝试\n大量的key集中过期（缓存雪崩）造成的后果：请求延迟增加 内存占用过高，为了避免这种情况，key的过期时间尽量随机 并开启lazy free机制（异步删除过期key 不会阻塞主线程的运行）\nRedis 的内存淘汰策略（6种）： Redis 的内存淘汰策略只有在运行内存达到了配置的最大内存阈值时才会触发，这个阈值是通过 redis.conf 的 maxmemory 参数来定义的\n2025-10-26 Redis事务 Redis 事务（并不是关系型数据库的事务），提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。日常开发中一般不适用redis事务。事务的ACID特性（原子性，一致性，隔离性，持久性），redis事务不支持回滚操作，所以Redis事务不支持原子性。redis支持持久性（重启后数据还在）：1.RDB快照,2.AOF只追加文件,3.混合模式\nAOF持久化的实时性更好 redis的配置文件中存放了三种持久化方式（fsyn）always，everysec，no 可以通过lua脚本配合Redis事务的缺陷。\n性能优化 1.可以使用批量操作减少网络传输，因为批量操作可以减少网络传输次数，减少网络开销，减少RTT(往返时延) 2.pipeline 对于不支持批量操作的命令 可以用pipeline将redis命令封装成一组 这些命令会被一次性传输给redis服务器 但是需要注意批量操作的元素个数，避免网络传输的数据量过大。 3.lua脚本 支持批量操作多条命令，可以看作是原子操作\n如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性\n大量key集中过期（缓存雪崩） 对于过期key Redis 采用的是 定期删除+惰性删除，为了解决缓存雪崩，1.需要给key设置随机过期时间（expire）2.开启lazy-free惰性删除（异步删除key，将删除操作交给单独的子进程处理 避免阻塞主线程）\nBigkey 如果一个key对应的value占用的内存比较大 这个key可以叫bigkey（例如1MB）。bigkey消耗了更多的内存空间和带宽 还会对性能造成影响：\n客户端超时阻塞：redis执行命令是单线程处理 如果遇到bigkey时会比较耗时 网络阻塞 工作线程阻塞：删除bigkey时会阻塞工作线程 如何找到bigkey：1.可以使用\u0026ndash;bigkeys参数查找redis中的bigkey，2.可以用redis自带的scan命令，当redis采用的时RDB持久化的时候，3.可以用开源软件分析RDB文件找出bigkey\n如何处理bigkey：1.可以将bigkey分割成小key 2.可以手动清理 3.开启惰性删除\u0026hellip;\nHotkey 如果一个key的访问次数明显多于其他key 这个key可认为是热点key 如果hotkey处理不好 redis会直接宕机 大量请求落到数据库中 可能导致数据库崩溃\n如何找到hotkey：1.当数据淘汰策略采用的是LFU最近最少访问的时候，可以用\u0026ndash;hotkeys参数查找redis的hotkey，返回所有key被访问的次数。2.可以用monitor命令 可以实时查看redis所有操作的方式 可以监控redis实例的操作情况（不建议用）3.开源软件\n如何处理hotkey：1.读写分离 主节点处理写请求 从节点处理读请求，2.可以使用redis cluster 将热点数据放在多个redis节点上 3.二级缓存（可以通过caffine/guava创建本地缓存）\n慢查询命令 redis命令执行：1.发送命令 2.命令排队 3. 命令执行 4.返回结果。redis慢查询统计的是命令执行的耗时 查询的是命令执行时间较长的命令。\n如何找到慢查询命令：通过查看慢查询日志，慢查询日志中记录执行时间超过指定阈值的命令。慢查询日志同样会占用一定的空间 可能会导致内存占用过高的问题。常见的命令： 查询慢日志SLOWLOG GET，清空慢日志SLOWLOG RESET，返回慢查询命令的数量 SLOWLOG LEN\nRedis生产问题 1.缓存穿透（查询的数据不在缓存也不在数据库中） 解决方案：缓存空值，布隆过滤器\n2.缓存击穿（热点key失效，大量并发请求访问数据库导致数据库负载过高） 解决方案：分布式锁，缓存预热，自动续期\n3.缓存雪崩（大量的key同时失效，或者缓存服务器宕机 导致所有请求访问数据库）解决方案：为key设置随机过期时间 设置多级缓存 使用高可用架构（Redis集群或哨兵模式或主从架构）\n缓存预热如何实现 缓存预热是防止热点数据不在缓存中 导致缓存击穿或缓存雪崩的一种解决方案 可以在系统启动或者高并发请求之前 将热点数据提前加载缓存中避免缓存失效。\n缓存预热的两种实现方式：1. 使用定时任务 2.使用消息队列\n缓存和数据库数据的一致性 参考：缓存和数据库一致性问题，看这篇就够了\n想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。\n对于1.先删除缓存，再更新数据库以及 2.读写分离 + 主从复制延迟情况下，缓存和数据不一致的问题，可以采用延迟双删策略（在更新数据库后，先删除缓存中的数据，然后延迟一段时间再删除一次缓存）。为了保证数据一致性和系统性能，只需要保证最终一致性即可 不用要求强一致性。\nRedis高可用架构 实际生产中 redis如果只部署一个节点 当机器故障的时候整个系统无法提供服务（单点故障），因此在集群模式下，将redis节点部署在一台或者几台，可用提高服务的可用性。\n1.主从模式：节点分为主节点和从节点 主节点进行读写操作，从节点只能进行读操作。主节点数据变化，将变化数据同步给从节点 保持数据同步（主从同步，刚刚连接的时候进行全量同步，全量同步结束之后，进行增量同步）\n2.哨兵模式：主从模式下，当主节点宕机之后需要将从节点改成主节点，需要人工干预，开销大。所以在实际生产中，优先考虑哨兵模式，主节点宕机后，哨兵自动选取主节点。一般为了便于选举主节点，选用奇数个哨兵。哨兵是一个独立的进程，哨兵进程向所有的redis机器发送命令，等待redis响应 从而监控多个运行的redis实例\n3.集群模式：主从模式和哨兵模式下，每台redis服务器存储相同的数据，浪费内存 。集群模式下实现redis的分布式存储，对数据进行分片，每个节点可以存储不同内容。QPS要求高的时候使用。\nRedis实现延时任务 实现方式：1.redis过期事件监听 2.redisson内置的延迟队列\n","date":"2025-10-19T00:00:00Z","permalink":"https://1parado.github.io/p/redis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"Redis 常见面试题"},{"content":"\r基础知识（hello 算法）\nhttps://www.hello-algo.com/chapter_array_and_linkedlist/array/\n数组：数组元素存储在连续的内存空间中，如果知道数组首地址和某个元素的索引，查找数据很简单，时间复杂度低O(1)，在数组中插入和删除需要移动元素，所以时间复杂度有点高O(N)。数组（静态）的长度是不可变的（ArrayList动态数组，长度未知的数组），如果扩容数组则重新建立一个更大的数组，复制旧数组的元素到新数组中。\n1 2 // 数组初始化 int[] nums = {1,2,3} or int[] nums = new int[3]; 链表：如果数组很大 内存无法提供这么大的连续空间 则可以使用链表这种数据结构。【value,*】， *指针指向下一个节点的内存地址。链表的尾节点指向null。\n1 2 3 4 5 6 初始化链表 节点1 -\u0026gt; 节点2 // 初始化节点 n0 = listNode(1) n1 = listNode(2) // 构建节点之间的引用 n0.next = n1 链表的插入和删除很简单，只需要改变引用即可O（1），但是查询数据的时候，需要从头节点向后遍历直到目标节点O(N)。\n数组和链表采用了相反的存储策略（一个连续，一个不需要连续），因此各种性质和操作效率都呈对立特点。\n链表的种类：单向链表，双向链表，环形链表\n1 2 3 4 5 6 7 /* 双向链表节点类 */ class ListNode { int val; // 节点值 ListNode next; // 指向后继节点的引用 ListNode prev; // 指向前驱节点的引用 ListNode(int x) { val = x; } // 构造函数 } 列表：元素的有序集合，可以基于数组和链表实现。数组实现的列表是一个有长度限制的列表，因此可以用动态数组来实现列表。列表本质是数组，查找元素很快O（1），插入和删除元素O(N). 列表可以拼接。关于列表的数据结构怎么设计的可以看源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 动态数组初始化 import java.util.ArrayList; import java.util.List; List\u0026lt;Integer\u0026gt; dynamicList = new ArrayList\u0026lt;\u0026gt;(); // 空列表 dynamicList.add(1); // 添加元素 dynamicList.add(2); dynamicList.addAll(java.util.Arrays.asList(3, 4, 5)); // 批量添加 //或者 List\u0026lt;Integer\u0026gt; dynamicList2 = new ArrayList\u0026lt;\u0026gt;(10); // 初始容量 10，可自动扩容 // 列表拼接 dynamicList.add(dynamicList2); // 列表排序（进行完列表排序后 可以使用二分查找和双指针算法） Collections.sort(dynamicList2); 搜索算法：\n暴力法：通过遍历数据结构中的每个元素定位目标\n自适应搜索：利用数据的特性（比如有序性）优化搜索过程\n“二分查找”利用数据的有序性实现高效查找，仅适用于数组。时间换空间\n“哈希查找”利用哈希表将搜索数据和目标数据建立为键值对映射，从而实现查询操作。空间换时间\n数组 二分查找 二分查找是一种基于分治法策略的高效搜索算法，利用数据的有序性，每轮缩小范围直到找到目标或者找不到目标。即给指针low和high分别设置搜索目标，目标可能是一个值，也可能是一个范围，最终他们要么找到目标终止循环，要么越过边界终止循环\n二分查找的优点：时间效率高O（logN），不需要额外的空间【哈希算法以空间换时间】\n二分查找的局限性：仅适合有序数组（不要想着先对无序数组排序再用二分查找，因为排序的时间复杂度就已经很高了），不能对链表进行二分查找，不适合数据经常变化的数组。\n1.二分查找 解题思路：数组有序 返回下标（查找元素）\u0026ndash;\u0026gt; 二分法 这里采用左闭右闭区间[low,high]所以while判断的时候是low \u0026lt;= high\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int low = 0; int high = nums.length - 1; int mid = (low + high)/2; // 向下取整 // int mid = low + （high - low） 这种也可以是为了防止溢出， while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; class Solution { public int searc mid = (low + high)/2; }else{ low = mid + 1; mid = (low + high)/2; } } return -1; } } 2.二分查找插入点（无重复元素）\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n犯的问题：粗心把high初始化的时候设置成 nums. length了，2，3，4情况返回值应该是high+1（要想明白为什么是high+1 ？\u0026ndash;\u0026gt;2，3，4情况下，当循环终止时，high指向小于target的元素，low指向大于target的元素，因此插入的索引应该是high + 1）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { // 可能出现的情况四种1.找到nums[mid] = target // 2.没出现 目标值在最前面 // 3.没出现 目标值在最后面 // 4.没出现 目标值在某个区间 // 2 3 4 要保证统一返回 int low = 0; int high = nums.length - 1; int mid = (high + low)/2; while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; mid = (high + low)/2; }else{ low = mid + 1; mid = (high + low)/2; } } return high + 1; // 注意这个是力扣上的题 是找到值就返回索引 } } 二分查找插入点（有重复元素）\n给定一个长度为 的有序数组 nums 和一个元素 target ，数组存在重复元素。现将 target 插入数组 nums 中，并保持其有序性。**若数组中已存在元素 target ，则插入到其左方。**请返回插入后 target 在数组中的索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 二分查找插入点（存在重复元素） */ int binarySearchInsertion(int[] nums, int target) { int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1] while (i \u0026lt;= j) { int m = i + (j - i) / 2; // 计算中点索引 m if (nums[m] \u0026lt; target) { i = m + 1; // target 在区间 [m+1, j] 中 } else if (nums[m] \u0026gt; target) { j = m - 1; // target 在区间 [i, m-1] 中 } else { j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中 } } // 返回插入点 i return i; } 3.找起始位置和终止位置 没思路(老老实实写两个函数 不要想着函数复用和其他方法了 边界处理太难想了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int[] searchRange(int[] nums, int target) { int left = searchLeft(nums, target); int right = searchRight(nums, target); if (left != -1 \u0026amp;\u0026amp; right != -1) { return new int[]{left, right}; } return new int[]{-1, -1}; } public int searchLeft(int[] nums, int target) { int low = 0, high = nums.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (nums[mid] \u0026gt;= target) { high = mid - 1; } else { low = mid + 1; } } if (low \u0026lt; nums.length \u0026amp;\u0026amp; nums[low] == target) return low; return -1; } public int searchRight(int[] nums, int target) { int low = 0, high = nums.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (nums[mid] \u0026lt;= target) { low = mid + 1; } else { high = mid - 1; } } if (high \u0026gt;= 0 \u0026amp;\u0026amp; nums[high] == target) return high; return -1; } } 移除元素 双指针：设计不同移动速度，不同间距，不同方向的两个指针进行操作 解决问题。指向相同序列一般有快慢指针，首尾指针，固定间距指针等。指向不同序列有归并排序。可以用来求链表的中点、链表是否成环、移除数组中多余的元素（原地移除）、归并排序 等\n1.移除元素（快慢指针法）\n思路：我一想到双指针脑子里面总是会想让i指向0，j指向i+1或者就是i指向0，j指向length-1.实际上的情况比这更复杂，不能用这种惯性思维来做题。（这道题是看了代码随想录的演示动画自己写的while循环 其实for循环比这个简单）\n首先确定指针表示的含义 i是指向新的子数组的下标，新数组中不允许有val j是用于找到非val值用于交换的元素 初始化：i=j=0 在循环中i和j的变化分情况讨论 nums[i]！=val时 不需要交换 只需要i和j同时向后移动即可 nums[i]=val时 分两种情况 nums[j]=val时，需要让j自己移动到不为val的地方，变成nums[j]!=val的情况 然后进行交换 交换后i和j再同时移动 循环终止条件：当j到达length - 1 的时候循环终止\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int removeElement(int[] nums, int val) { // i指针指向的数组中不允许有val j指针用于找到非val的元素 // 指针初始化位置 i=j=0 int i = 0; int j = 0; while(j \u0026lt;= nums.length - 1){ if(nums[i]==val){ if(nums[j]!=val){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j++; }else{ j++; } }else{ i++; j++; } } return i; } } // 第二种解法（推荐） class Solution { public int removeElement(int[] nums, int val) { int i = 0; int j = 0; while(j\u0026lt;nums.length){ if(nums[j]!=val){ // 注意这个地方的执行顺序 如果先让i++ 然后再覆盖的话就会出现溢出错误 因为这是数组 i实际是个数字不是指针不会发生指针溢出的情况 如果让数组取nums[length]才会报错 nums[i] = nums[j]; i++; } j++; } return i; } } 2.26. 删除有序数组中的重复项 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int removeDuplicates(int[] nums) { int i = 0;//slow int j = 0;//quick while(j\u0026lt;nums.length){ if(nums[i]!=nums[j]){ i++; nums[i] = nums[j]; } j++; // 这一步是每次都会执行的，并不是执行完if语句就不执行了 } return i+1; } } date: 2025-10-19\n283. 移动零 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public void moveZeroes(int[] nums) { int i=0; int j=0; while(j\u0026lt;nums.length){ if(nums[j]!=0){ nums[i] = nums[j]; i++; } j++; } //比如初始数组是【1，0，2，0，3】 结束时数组是【1，2，3，0，3】所以需要对后面的进行赋零操作 要想清楚结束的时候i指向哪 while(i\u0026lt;nums.length){ nums[i] = 0; i++; } } } 977. 有序数组的平方 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int[] sortedSquares(int[] nums) { // 首尾双指针 int i = 0; int j = nums.length-1; int k = 0; int[] nums2 = new int[nums.length]; while(i\u0026lt;=j){ if(nums[i]*nums[i] \u0026lt;= nums[j]*nums[j]){ nums2[k] = nums[i]*nums[i]; i++; }else{ nums2[k] = nums[j]*nums[j]; j--; } k++; } Arrays.sort(nums2); // 无返回值 直接对原数组进行操作 return nums2; } } 209. 长度最小的子数组 - 力扣（LeetCode）\n滑动窗口O（N）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 第一种解法 时间复杂度和空间复杂度都是O(N) 使用了滑动窗口和动态数组 可以不用动态数组而是用一个变量来记录min_length class Solution { public int minSubArrayLen(int target, int[] nums) { int i = 0; int sum = 0; ArrayList\u0026lt;Integer\u0026gt; length_list = new ArrayList\u0026lt;\u0026gt;(); // for(int j = 0;j\u0026lt; nums.length; j++){ sum += nums[j]; // 先大范围找 移动j 在满足粗略的条件之后再缩小范围 移动i【i和j都是只增不减的 双循环的时候j会变小】 while(sum \u0026gt;= target){ int length = j - i + 1; length_list.add(length); sum -= nums[i]; i++; } } if(length_list == null || length_list.isEmpty()){ return 0; }else{ int min_length = Collections.min(length_list); return min_length; } } } 59. 螺旋矩阵 II - 力扣（LeetCode）\n主要是考察边界条件的判断\n区间和: 可以用sum数组保存前n项和 如果想计算下标2-5的区间和 可以通过前5项和-前二项和\n链表 \u0026mdash;2025.10.20\n链表节点类\n1 2 3 4 5 6 7 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } 链表删除节点 直接让next指针被删除节点的下一个节点即可 Java有自己的回收机制 被删除的节点会自动回收\n关于链表的Java语法都忘完了 删除元素就是 current.next = current.next.next; 还需要注意什么时候创建的是节点 什么时候创建的是指针\n203. 移除链表元素 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode removeElements(ListNode head, int val) { // 设置一个虚拟头节点vir 以及一个当前指针cur用来遍历 ListNode vir = new ListNode(); vir.next = head; //vir放在head前面作为虚拟头节点 ListNode cur = vir; // cur指针指向当前遍历的节点 while(cur.next!=null){ //考虑清除循环终止条件 当cur遍历到最后一个节点 即cur.next == null 时终止循环 if(cur.next.val == val){ cur.next = cur.next.next; //如果cur指向的节点值为val 则移除 }else{ cur = cur.next; // 移动cur到下一个节点 } } // 返回值难以确定时 考虑极端情况试试 // 当首节点为val时 就会被删除 所以vir.next是正确的 而不是head return vir.next; } } 707. 设计链表 - 力扣（LeetCode）\n在链表类中还需要设置链表的size 和 head 以及初始化链表 最关键的就在于如何初始化 如何循环 以及如何结束循环\n2025.10.21\n206. 反转链表 - 力扣\n反转链表（也不会 算法好难！！！\u0026ndash;果然还是安静的时候写算法题有效果）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { // 双指针 ListNode cur = head; // 当前节点指针 ListNode pre = null; // 当前节点指针的前一个节点 // （我想的太多了 我想着如果转换方向之后 后一个节点就找不到了 可以用临时temp记录一下就好了啊！） while(cur != null){ ListNode temp = cur.next; // 记录一下当前节点的下一个节点的位置 cur.next = pre; pre = cur; // 然后让pre向后移动 即指向cur cur = temp; // 让cur指向temp } return pre; } } 24. 两两交换链表中的节点 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //我想的是设置一个flag 来判断是否需要交换 然后用一个temp表示cur节点的后一个节点 用于交换 即在循环体中 1.temp = cur.next临时保存 // 2.cur.next-\u0026gt;temp.next 3. temp.next-\u0026gt;cur 但是有错误！！！ 2-1-3-5 4-3-5 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next ==null){ // 链表为空/链表中只有一个元素 return head; } // 这个代码是错误的 结果是2-1-3-5 4-3-5 ListNode cur = head; while(cur.next !=null ){ ListNode temp = cur.next; // 这是用temp记录后一个节点不行 试试用temp记录pre cur.next=temp.next; temp.next=cur; cur = cur.next; } return cur; } } 错误代码2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next ==null){ // 链表为空/链表中只有一个元素 return head; } ListNode vir = new ListNode(); vir.next = head; ListNode cur = head; ListNode pre = vir; while(cur.next !=null \u0026amp;\u0026amp; cur.next.next!=null){ pre.next = cur.next; cur.next = cur.next.next; pre.next.next = cur; pre = pre.next; cur = cur.next; } return vir.next; } } 正确代码：\n19 删除倒数第N个节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 解题思路（Mine）：先找到这个节点是正数第几个位置 然后找到其前置节点 进行删除操作 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode vir = new ListNode(); vir.next = head; ListNode cur = vir; int size = 0; // 遍历一遍得到链表的size while(cur.next != null){ size++; cur = cur.next; } int z = size - n + 2; //倒数第n是正数第size - n + 1 这里的z = size - n + 1是其前节点 ListNode vir2 = new ListNode(); vir2.next = head; ListNode cur2 = vir2; int count = 1; // 要注意这里的count是从1开始的 是指链表中的第几个节点 while(cur2.next != null){ count++; if(count == z){ cur2.next = cur2.next.next; return vir2.next; } cur2 = cur2.next; } return vir2.next; } } 面试题02.07链表相交\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 第一种方法（Mine），第二种方法用双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 需要让长链先走 然后同步移动 看是否有节点相交 int A_size = 0; // A链表的长度 int B_size = 0; // B链表的长度 ListNode A_cur = headA; ListNode B_cur = headB; if(headA == null || headB==null){ return null; } while(A_cur != null){ //在计算链表长度的时候 循环条件里面是cur 不是cur.next A_size++; A_cur = A_cur.next; } while(B_cur != null){ B_size++; B_cur = B_cur.next; } // 我想的是计算出A和B的长度差（用绝对值Math.abs(),但是这样还是区分不了哪个长哪个短） // int length = Math.abs(A_size,B_size); int length = 0; ListNode slow = null; // 指向长链表的头节点 ListNode quick = null; // 指向短链表的头节点 if(A_size - B_size \u0026gt;= 0){ length = A_size - B_size; quick = headA; slow = headB; }else{ length = -1 * (A_size - B_size); quick = headB; slow = headA; } // 将长链表的指针和短链表的指针同步 while(length \u0026gt; 0){ quick = quick.next; length--; } while(quick != null){ // 注意这里不是quick.next 如果是这样 首节点都没有比较 如果设置了虚拟节点可以是vir.next if(quick == slow){ return quick; } quick = quick.next; slow = slow.next; } return null; } } 142 环形链表ii 如何判断一个链表中是否有环？ 快慢指针 fast 每次走两步 slow 每次走一步 最终会在环内相遇 fast会追上slow 因为在环内fast相当于每次都逼近slow一个节点 难点在于如何确定哪个节点是入环点！\n【注意：链表中有些题目没有看别人优秀的题解 有些甚至都没做出来 显然下次遇到了 脑子里首先弹出来的还是自己不成熟的想法 没有形成一个自己的解题逻辑 这是不对的！应该吸收别人的思想为己所用】\nHash 表 哈希表可以快速判断一个元素是否出现在集合里 key-func（key）-value，但可能出现哈希冲突 不同的key映射到同一个value，解决方法：拉链法和线性探测法。 常见的哈希结构：数组，集合set，map。空间换时间。当遇到需要判断一个元素是否出现过 就要想到哈希法\n242.有效的字母异位词\n","date":"2025-10-17T00:00:00Z","permalink":"https://1parado.github.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/","title":"代码随想录(长期更新)"},{"content":"\r2025.10.17 哈希 补充知识： https://javaguidepro.com/blog/hash-table-java/\n哈希表是根据key直接访问存储位置的暑假结构，key\u0026ndash;\u0026gt;hash函数\u0026ndash;\u0026gt;存储桶，每个存储桶可以存储一个或多个键值对。（哈希冲突即不同的键映射到同一个存储桶中）\n1.Hashtable 是 Java 中最早提供的哈希表实现，它是线程安全的，不允许键或值为 null\n2.HashMap 是 Java 中最常用的哈希表实现，它不是线程安全的，允许键和值为 null\n3.LinkedHashMap 是 HashMap 的子类，它维护了一个双向链表，用于记录键值对的插入顺序或访问顺序\n当需要查询一个元素是否出现过，或者一个元素是否在集合里\u0026mdash;\u0026gt;哈希法。用空间换时间，可以用数组、set、map\u0026hellip;做哈希法\n两数之和 题解1. 双重循环 题解2. 哈希法 Map（key，value） （我想的一个是双重循环，一个是排序比较，但是注意审题，排序之后下标都变了肯定不对！） a + b = target， 当指针指到a时，可以去map中找b是否存在。key存放值，value存放下标\n参考题解: https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md\n代码： class Solution { public int[] twoSum(int[] nums, int target) { // 创建一个返回数组 int[] res = new int[2]; // 当传入的数组为空 直接返回[ , ] //数组为null是空引用，并没有创建这个数组对象 数组长度为0是有这个数组对象但数组元素为空 if(nums == null || nums.length == 0){ return res; } Map\u0026lt;Integer,Integer\u0026gt; indexMap = new HashMap\u0026lt;\u0026gt;(); // 遍历到某个a元素的时候，去map中找是否有满足target - a = b的b元素 有则将两者下标返回 没有则加入map // nums[i]当作key, i当作value for(int i = 0; i \u0026lt; nums.length; i++){ if(indexMap.containsKey(target - nums[i])){ res[0] = i; res[1] = indexMap.get(target - nums[i]); return res; } indexMap.put(nums[i],i); // haspMap插入key-value键值对 } return res; } }\n移动零\nclass Solution { public void moveZeroes(int[] nums) { int[] res = new int[]; if(nums == null || nums.length == 0){ return res; }\n}\r}\n2025.10.22 普通数组： 53.最大子数组和\n1.我首先想的是双指针 但是最大子数组和不具备单调性，无法使用常规的“滑动窗口”技巧（即不能通过移动左右指针来收缩或扩展窗口以逼近答案）\u0026ndash;方法选用不当 不知道什么算法应该解决什么问题 2.前缀和 用数组来保存前缀和 这里又有几个坑 比如不能让fix_num += num[i] 因为fix_num中的元素初始化都为0 这相当于 fix_num = num[i]。 求前缀和可以用sum+=num[i],然后让fix_num[i] = sum; 而且要注意，不能简单的用最大前缀和-最小前缀和，要满足这个最大前缀和在最小前缀和的右边 否则不能计算。\n1 2 3 4 5 6 7 8 9 // 生成前缀和数组 int sum = 0; int[] fix = new int[nums.length]; int index = 0； for(int x : nums){ // 这里的x是数组的元素 不是下标 sum += x; fix[index] = sum; index++； } 最大区间和 = fix[j] - fix[i-1]，其中 i \u0026lt;= j 要使这个差值最大，就要让 fix[j] 尽可能大，fix[i-1] 尽可能小，且 i-1 \u0026lt; j.【为什么是减去fix[i-1]???】 3.动态规划DP\n二分查找： 力扣35 搜索插入位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { // 可能出现的情况四种1.找到nums[mid] = target // 2.没出现 目标值在最前面 // 3.没出现 目标值在最后面 // 4.没出现 目标值在某个区间 // 2 3 4 要保证统一返回 int low = 0; int high = nums.length - 1; int mid = (high + low)/2; while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; mid = (high + low)/2; }else{ low = mid + 1; mid = (high + low)/2; } } return high + 1; } } 74.搜索二维矩阵\n我的想法就是将二维矩阵变成一维数组 然后再使用二分查找 因为这个题目中的数组都是m行n列的。别人的题解说可以用两次二分查找，之后记得看看！\n1.如何遍历二维数组并将其转换为一维数组？\n1 2 3 4 5 6 7 8 9 10 11 int m = matrix.length; // 行数 int n = matrix[0].length; // 第一行的列数 matrix[i].length表示第i行的列数 int[] nums = new int[m*n]; int index = 0; for(int i = 0;i\u0026lt;m;i++){ for(int j = 0;j\u0026lt;n;j++){ nums[index] = matrix[i][j]; index++; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 完整代码 class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length; // 行数 int n = matrix[0].length; // 第一行的列数 int[] nums = new int[m*n]; int index = 0; boolean flag = false; for(int i = 0;i\u0026lt;m;i++){ for(int j = 0;j\u0026lt;n;j++){ nums[index] = matrix[i][j]; index++; } } int i = 0; int j = nums.length - 1; while( i \u0026lt;= j){ int mid = i + (j-i)/2; if(target \u0026gt; nums[mid]){ i = mid+1; }else if(target \u0026lt; nums[mid]){ j = mid -1; }else{ flag = true; return flag; } } return flag; } } 34. 在排序数组中查找元素的第一个和最后一个位置\n寻找左边界（不含target）和右边界（不含target） 主要还是要考虑清楚返回值是什么 要考虑target 存在和不存在的情况？？？？\n33. 搜索旋转排序数组\n我想的是让这个旋转后的数组变成一个有序数组 然后进行二分查找 找到target 即新建一个数组存放原始未旋转的数组 然后找到在这个数组中target的下标 再去求旋转后数组的下标 但是有个问题 找旋转点的过程需要遍历整个数组O(N)\n为什么情况是这么多种？？？？ 1.二分后，左边的数组是升序的(nums[0]\u0026lt;nums[mid]) 1.1 target\u0026gt;nums[mid]：应该往右边搜索 1.2 target\u0026lt;nums[mid]并且target\u0026lt;nums[0]：应该往右边搜索 1.3 target\u0026lt;nums[mid]并且target\u0026gt;=nums[0]：应该往左边搜索\n2.二分后，左边的数组是存在翻转点的(nums[0]\u0026gt;nums[mid]) 2.1 target\u0026lt;nums[mid]并且target\u0026gt;=nums[0]：应该往左边搜索 2.2 target\u0026lt;nums[mid]并且target\u0026lt;nums[0]：应该往左边搜索 2.3 target\u0026gt;nums[mid]并且target\u0026lt;nums[0]：应该往右边搜索 2.4 target\u0026gt;nums[mid]并且target\u0026gt;=nums[0]：应该往左边搜索\n完成情况：（左右边界那题也不熟悉） 2025.10.23 今天换了一种刷题的策略 不按照分类做了 直接按照题单顺序来做 我觉得简单题其实难度还好 中等难度的题我就A不出来了 主要还是在于我的数据结构基础掌握的不是很牢固 今天刷题的时候遇到的问题：\n1.hashmap怎么初始化 hashmap的操作 hashMap怎么遍历 怎么获得key 怎么获得value\n2.动态数组ArrayList怎么创建 ArrayList的常见操作\n3.位运算 异或运算符^，异或运算的性质 \u0026ndash;相同为0，不同为1 任意数与0异或，结果仍是它本身。与运算 \u0026amp;\n4.数组内置排序：Arrays.sort( )\n5.Java支持十进制数字直接进行逻辑运算（计算的时候是按照二进制进行计算的） 2025.10.25 今天把之前写过的简单题回顾了一下 其中还是有一些题A不出来的 而且有的时候想法太多 一道题目把好几道题解想混了 就越想越多 反而做不出来 而且这些题解的时间复杂度和空间复杂度还有优化的可能 未来需要学习别人高阶的题解，还有一个问题是我对Java中内置的函数了解的不多 导致重复造轮子 写起来就比较吃力。 如果让我回顾一下简单题的知识点的话，首先是数据结构的实现：链表的数据结构（单链表），树的数据结构（二叉树）。主要涉及到的知识点：数组，动态数组ArrayList，HashMap（如何遍历HashMap），链表，位运算（异或，按位与），双指针，递归，二分查找。总体来说今天的状态还是满意的 写了16道题 想不出来实现方法/报错的有四五道 还可以接受。\n今天没做出来的题目：反转链表，买卖股票的时机，移动零，删除链表倒数第N个节点 具体的实现代码我放在GitHub上面了，hot100 简单题回顾\n2025.10.28 昨天公司派活了 在公司摸索一天 所以昨天就写了两道算法题 今天在公司依然在摸索 今天也写了两道题 不知道这种刷题策略有没有效果哦？ [hot100双指针](1parado_repo.github.io/leetcode1028.java at main · 1parado/1parado_repo.github.io) 今天写了移动零和盛水最多的边界 也就是快慢指针和首尾指针 三数之和那道题 大致意思看懂了 但是让我自己实现有一点麻烦 之后再复习。\n","date":"2025-10-17T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%8A%9B%E6%89%A3hot100/","title":"力扣hot100"},{"content":"\rRuoYi-Vue-Pro: https://doc.iocoder.cn/quick-start/\n后端版本:我下载的mini版本的，只有一些简单的功能，其中的一些功能是受限的 https://github.com/YunaiV/ruoyi-vue-pro\n前端版本：Vue3 + element-plus 版本 https://github.com/yudaocode/yudao-ui-admin-vue3/\n按照RuoYi配置文档一步一步来其实挺好搭建的，主要是要先配置环境。\n","date":"2025-10-16T00:00:00Z","permalink":"https://1parado.github.io/p/ruoyi%E6%A1%86%E6%9E%B6/","title":"RuoYi框架"},{"content":"\r⚫ 找论文的一些网站（有些网站要翻墙） Google scholar⭐⭐⭐⭐⭐： 可以配合谷歌插件Easy scholar直接显示期刊的等级和影响因子 2.Web of science⭐⭐⭐\n3.Sciencedirect⭐⭐⭐\n4.Ieeexplore⭐⭐⭐\n5.Arxiv⭐⭐预印的期刊，文章比较新但可能有小错误\n6.CNKI 中文知网⭐⭐\n⚫ 文献管理工具： Zotero + 翻译插件: https://blog.csdn.net/xiaoningaijishu/article/details/151042814\nIma腾讯推出的个人知识库（英文不好的强烈推荐！）把论文上传到知识库中，然后全局翻译，翻译的很准确，而且可以根据知识库进行提问。\n小绿鲸（我没用过，看师兄用过）: https://www.xljsci.com/\n⚫ 笔记软件： Notion，Obsidian，Ima，Typora, Cherry studio\u0026hellip;推荐Obisidian 轻量化（但其实没有做笔记的习惯的话不下载也可以）\n⚫ 用于论文写作的一些工具 overleaf是一款在线编写latex格式的论文写作软件，可以配合浏览器插件Grammarly检查语法错误 https://app.grammarly.com/\noverleaf模板: https://cn.overleaf.com/latex/templates 点 Journal Article 找对应的论文模板格式下载压缩包 导入到overleaf即可编写操作\n习惯用Vs code的可以在vscode中下载overleaf的插件 直接在vscode中编写也可:https://zhuanlan.zhihu.com/p/29808221714\n⚫ 好用的网站： 表转latex格式 https://tablesgenerator.com/\nlatex公式在线编写： https://www.latexlive.com/home\nCanva做汇报ppt: https://www.canva.cn/\nBoardmix做思维导图: https://boardmix.cn/app/home\nProcesson做流程图: https://www.processon.com/\nVison也可以画流程图，可以导出矢量图.svg格式，适合放在文章里面做流程图:https://blog.csdn.net/laowangpython/article/details/147465427\n⚫ AI工具： 我常用的ai就是下面这些，主推GPT和Grok，其他的可以在论文写作的时候，优化论文表达的时候用。【小技巧：可以自己写中文初稿，然后让gpt翻译成英文，再截图让gpt生成latex格式，直接复制到overleaf里即可，英文好的话直接用英文写也可以】\n1.chatgpt: https://chatgpt.com/\n2.grok: https://grok.com/\n3.kimi: https://www.kimi.com/\n4.deepseek: https://chat.deepseek.com/\n每个课题组的研究方向不一样，发论文的难度也不一样，下面只是我的研究过程： 先确定研究方向，然后读最新的几篇综述（最好选英文文献，中文也可以），然后找一篇感觉能复现出来的文章进行复现（可以发邮件给作者看看能不能要到源码，最好多问几个，真的有人愿意给的/用AI帮忙），然后在该文章的基础上想一下有没有可以新增的点（看论文的未来展望/和其他论文模型进行融合），一篇好的论文需要天时地利人和，EI会议随便写，好多都是论文A的模块 + 论文B的模块整合到一起得到自己的创新模型。\n以我们组的研究方向为例：网络弹性量化（Cyber resilience quantification），在文献搜索网站上面搜关键词，然后读几篇综述，大致了解一下网络弹性评估包括车联网，信息关键基础设施网络，电网，无人机集群网络\u0026hellip;.本来是研究车联网的，然后组会汇报两次无人机相关文章，莫名其妙研究方向变成无人机了，也算找到了研究领域:无人机集群网络弹性评估。然后读无人机集群网络弹性评估的文章，暑假开始，老师让复现文章，刚开始一直没复现出来，联系好多文章作者要源码，最后有一个学长给了我他的部分代码，然后复现他的这篇文章，在他的文章基础上加了一些模块解决了一些现有研究领域没有解决的问题。（文章还没发，不敢把论文放网上）满打满算两个多月写一篇EI是够用的。\n","date":"2025-10-16T00:00:00Z","permalink":"https://1parado.github.io/p/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/","title":"科研论文写作"},{"content":"\r参考链接：https://javaguide.cn/database/mysql/mysql-questions-01.html\n📚 数据库基础 ER图 提供实体（方块） 属性（椭圆）和联系（菱形）的方法 关系：1对1，1对多，多对多\u0026hellip; 在创建项目之前应该先构建好数据库 并且绘制ER图来理清数据之间的关系。\n数据库范式：1NF（属性不可再分）,2NF（在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖）,3NF（在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖），BCNF（在3NF的基础上 去除属性见不必要的函数依赖）\n主键：唯一标识一个元组（行）不重复不为空，一个表只有一个主键\n外键：与其他表建立联系 外键是另外一个表的主键 可以重复可以为空 一个表可以有多个外键\n一般不推荐外键：1.增加了复杂性 2.增加了维护外键的工作量 3.对数据库分表不友好\n外键的好处：1.保证数据一致性和完整性 2.级联操作简单\ndrop 删除表结构 turncate 清空表数据 delete使用where限定删除某一行数据/清空表数据\n执行速度drop\u0026gt; turncate \u0026gt;delete\n数据库设计：需求分析-ER图-ER图转为表-选取数据库和存储结构-编程测试试和运行-运行和维护\n关系型数据库:如 mysql 支持事务的四大属性：ACID属性（原子性，一致性，隔离性，持久性）\n非关系型数据库: 如redis 天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。非关系型数据库比较灵活，性能高，可扩展性强\n字符集：GBK,ASCII,UTF8\u0026hellip; MySQL8.0默认字符集utf8mb4\nDDL数据定义语言: 定义数据库对象 CREATE、ALTER、DROP\nDML数据操纵语言 : 访问数据，因此其语法都是以读写数据库为主 CRUD\nDCL数据控制语言 : 控制用户的访问权限 授予权限GRANT、收回权限REVOKE\nTCL事务控制语言：管理数据库中的事务 , 提交事务commit 回滚事务 rollback\n索引⭐【面试被问到了】\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构\n分为：唯一索引 主键索引 聚集索引 哈希索引\nhttps://javaguide.cn/database/mysql/mysql-index.html\nsql（结构化查询语言） 语法常见面试总结可以去牛客上看 也可以刷力扣上的sql 题 这里我就不着重看了 之后刷sql题的时候再看\n容易混淆的点：\nDecimal 可以存精确的小数 Float / Double 只能存近似的小数 DateTime 没有时区信息 八字节存储 TimeStamp 和时区有关 四字节存储 Null 1.null表示缺失的值 2.任何值与null比较结果都是null 3.有些聚合函数忽略null “ ” 1.空字符串 2.“ ” 可以进行比较，如 “ ” = “ ”结果为true 3. 聚合函数不忽略 MySQL执行流程：\n连接器（进行身份验证） 分析器（进行词法分析 和 语法分析） 优化器（按照MySQL认为最优的方案执行） 执行器（执行语句 从存储引擎返回数据） **存储引擎⭐（InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，只有InnoDB支持事务） 存储引擎采用插件式架构 ，基于表结构而不是数据库\nMySQL 日志⭐\n常见的日志分类:错误日志，查询日志，慢查询日志（可以结合 EXPLAIN 分析查询执行计划，优化索引或 SQL 结构，可用于性能优化），二进制日志（主从复制），回滚日志，重做日志（保证事务的持久性）\u0026hellip;\nMySQL事务：逻辑上的一组操作要么都执行要么都不执行。事务分为扁平事务（最简单的情况），嵌套事务，分布式事务\u0026hellip; 事务的四大属性ACID. 事务的目的就是为了保证数据的一致性。\n并发事务带来的问题：脏读，不可重复读，幻读，丢失修改（四种问题基本概念是什么？如何解决？）\n并发事务的控制方式：\n锁，通过读写锁来显式控制共享资源 分为表级锁（对整表加的锁）和行级锁（对索引字段加的锁），MyISAM 仅仅支持表级锁，InnoDB两者均支持。无论是表级锁和行级锁都存在共享锁S和排他锁X。意向锁可以来快速判断是否可以对某个表使用表锁，从而有了意向共享锁IS和意向排他锁IX MVCC（多版本并发控制）即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。 事务隔离级别（级别越高，数据一致性越好，但并发性能可能越低）：1.读未提交 2.读已提交 3.可重复读（MySQL默认的隔离级别） 4.可串行化。 MySQL 的隔离级别基于锁和 MVCC 机制共同实现的\n当前读和快照读\n当前读 = 当前最新数据 + 会加锁 → “最新、可能被阻塞”\n快照读 = 事务快照 + 不加锁 → “旧版本、不会被阻塞”\nMySQL调优⭐\nhttps://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html\nMySQL可以存文件（文件转为二进制文件存入MySQL），但是影响数据库性能占用太多存储空间。可以用云服务厂商提供的对象存储如OSS\u0026hellip;也可以用MinIO开源项目实习分布式文件服务。\nhttps://www.51cto.com/article/716978.html\nMySQL性能优化：慢查询日志找 SQL → Explain 看执行计划（分析性能） → 索引优化/表结构优化\u0026hellip; → 锁和 IO 分析 → SQL 重写 → 测试验证\n读写分离：读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。\n如何实现：主数据库和从数据库数据实时同步（主从复制），写请求交给主数据库处理，读数据库交给从数据库处理。\n主从复制：主数据库的数据变化写入二进制日志，从库链接主库，主库创建I/O线程发送二进制日志给从库，从库将二进制日志写入中继日志（Relay log）然后从库的sql线程读取中继日志实现主从数据实时同步（可能会发生主从同步延迟）\n第一种实现方式：代理方式\n在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。\n第二种实现方式：组件方式\n引入第三方组件来帮助我们读写请求。\n分库分表：如果一张表的存储数据量太大就要分库分表。分库分为水平分库（按照数据划分，行划分）和垂直分库（按照业务划分，属性划分）分表与分库同理。分库分表之后需要解决事务问题，分布式id问题，join操作问题\n冷热数据：热数据是指经常被访问和修改且需要快速访问的数据，冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。可以按照时间和访问频率划分。\n延时双删⭐【面试被问到了】（保证数据一致性）：首先删除redis中的缓存数据，然后更新数据库中的数据，让当前线程休眠一段时间，唤醒之后再次删除redis的缓存数据。\n2025.10.19\nMySQL高性能优化规范建议总结（了解即可） 数据库命名要规范 所有表使用InnooDB存储引擎 数据库和表的字符集统一使用utf8 单个表的数据量大小尽量在500万之内，再大可以考虑分库分表。对于日期类型用Datatime或timestamp 不要用字符串存储。可以通过查询MySQL的慢查询日志发现需要进行优化的sql语句。对于超100万行的批量操作（插入，更新，删除）要分批多次进行操作，因为大批量操作可能会造成主从延迟。\n重点【重新看一下】 索引：索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。常见的索引结构：B-Tree索引、B+树索引、Hash索引、红黑树索引\u0026hellip; InnoDB和MyISAM都选择B+树作为索引结构. 索引的优缺点：\n优点：1.查询速度快减少磁盘I/O次数 2.保证数据的一致性（唯一索引）3.可以加快排序和分组\n缺点：创建和维护耗时，占用存储空间,当数据量太小的时候全表扫描速度会比索引快。\n索引： 1.按照数据结构分类：B-Tree索引、B+树索引、Hash索引、红黑树索引\u0026hellip; 2.按照底层存储方式分类：聚集索引和非聚集索引 3.应用维度分类：主键索引，唯一索引，普通索引，覆盖索引\nB数和B+树的区别：1. B树的每个节点都存了key和data，B+树的data只存在叶子节点。非叶子节点仅存在key，可以让B+树更低，磁盘I/O操作次数更少。2. B+树所有叶子构成有序链表按照主键排序遍历全部记录 支持范围查找。\n主键索引：一个表只有一个主键索引，主键索引不能为null，不能重复。如果设计表的时候没有符合的字段（唯一且不为null），InnoDB会自动创建一个自增字段作为主键索引。\nEXPLAIN 分析执行计划 通过查询优化器对语句进行分析 找出最优的查询方法 并显示对应的信息\nMySQL三大日志：\n二进制日志（Binary log）：记录了所有对数据库的DDL和DML操作。可以用于数据备份，主从复制 ","date":"2025-10-15T00:00:00Z","permalink":"https://1parado.github.io/p/mysql-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"Mysql 常见面试题"},{"content":"\r2025.10.15 这是创建的 思维导图\n2025.10.21\n登录模块 登录鉴权 ：该项目采用SpringAOP + 自定义注解@RoleRequire实现RBAC鉴权\n现有的登录鉴权方式：\nSpringSecurity+RBAC模型+JWT实现认证与授权 SpringBoot + Sa-Token + MyBatis + MySQL + Redis 实现用户鉴权、角色管理、权限管理 Apache Shiro 是一个轻量级的安全框架，适合需要简单易用的权限管理的项目 自定义 定义用户、角色、权限三张表，设计合理的关联关系， 使用拦截器或 AOP 实现权限校验逻辑。根据业务需求设计动态权限分配机制。 JWT实现无状态认证（不需要服务器存储用户的会话状态），一个JWT包括头部，载荷，签名。\n过程：用户登录认证时，服务端验证用户身份，成功的话，服务端生成JWT返回给客户端，客户端在之后的请求中将JWT放在请求的头部（Authorization）,然后服务端通过解析JWT从而确定用户的身份和权限\n双token机制实现无感刷新：分为两种token 一种是access token（访问令牌）短期有效 ，一种是 refresh token（刷新令牌），长期有效。\n过程：客户端登录，认证成功，服务端签发access_token（返回给前端）和refresh token（存入cookie） 之后，客户端访问接口都带着access_token 当access_token过期之后 客户端发送给refresh token给服务端 验证通过则生成新的access token和refresh token，从而实现无感刷新\n双 Token 认证机制：从原理到实践的完整实现双 Token 认证机制：从原理到实践的完整实现 在现代 Web 应用中 - 掘金\n登录模块展示：首先进入登录页面： 然后根据角色的不同，进入不同的主页，系统分为三种角色Admin,Teacher,Student 秒杀抢课模块 1.获取动态路径 使用UUID + MD5生成一个唯一标识符 结合前端URL生成动态路径 避免被脚本直接访问\n2.实现限流保护 使用令牌桶实现限流保护（ Redis + 令牌桶算法），这里创建一个工具类TokenBucket，里面的参数包括桶的最大容量，间隔几秒补充几个令牌，当前可用令牌数\u0026hellip;方法包括令牌补充refill和获取令牌逻辑try Acquire 从而实现限流。\n还可以利用redission实现分布式限流 基于 Redisson 的分布式限流实战：令牌桶算法的优雅实现 - 你小志蒸不戳 - 博客园，比如保护AI访问的API\n其他限流方式：固定窗口、滑动窗口、漏桶限流和令牌桶限流算法\n检验动态路径（在获取动态path的时候会将动态path存入Redis，用于此时的动态路径校验） 检查当前用户是否重复秒杀 (幂等控制) 通过三级缓存实现 本地缓存采用Caffine/Guava 二级缓存采用Redis 三级缓存采用数据库 当发现任意一级的数据库中已经有选课记录了 就返回重复秒杀异常 幂等性指的是一个操作，无论执行多少次，都能得到相同的结果，即它不会因为执行多次而影响系统的状态。这在处理网络请求、数据库操作等场景中尤为重要，例如在订单支付、消息推送等操作中，即使因为网络延迟或其他原因导致多次请求，也应保证操作只执行一次，避免重复处理。\n进入秒杀的核心阶段 Redis + Lua脚本 + RocketMQ 实现 库存预减 + 异步入队\n从零开始实现秒杀系统（三）：RocketMQ消息队列篇 - Xun\u0026rsquo;s Blog\nLua脚本进行双重判断，首先判断是否售罄标志，然后再判断库存预减之后的库存数量，并且在脚本中实现库存减1的操作 如果成功返回1 失败返回 0.Lua脚本返回成功，系统发送消息到消息队列（RocketMQ）采用事务消息机制保证数据的最终一致性。\n生产者发送半消息 本地事务创建选课记录（订单） 根据事务的执行结果通知Broker是投递该消息还是丢弃该消息 消费者异步从MQ中消费信息 完成后续业务。\n页面展示： 首先填写预选课信息（类似于商城系统的购物车），然后查看选课信息（普通选课和秒杀抢课） 如果用户是首次抢课且库存充足，则显示抢课成功 如果用户重复抢课则提醒请勿重复秒杀 Admin端新增抢课信息 当学生张三选过课程之后，该课程已经“售罄”了 接下来用李四来选课会提醒库存不足 抢课失败 之后可以考虑用jmeter测试高并发场景下的抢课情况。\n支付模块 支付过程：\n用户点击缴费 进入AliPayController 用请求头中的Authorization进行身份验证 用请求体中的PaymentPO来生成缴费信息【前端会收集页面信息 当用户点击缴费按钮就会构建PaymentPO写入请求体中传给后端】 初始化订单信息 订单的状态初始化为0 标识未缴费 每个订单有一个唯一的订单号 使用创建好的支付工具类PayUtil 调用支付宝接口完成支付流程\nPayUtil中的核心方法即发起支付和查询支付结果方法： 发起支付：1.初始化支付宝客户端 2. 创建支付请求 3.设置业务参数 4.发起请求并且返回支付结果 查询支付结果：创建查询请求-执行查询-处理查询结果\n结果展示： 学生点击缴费之后，跳转到支付页面 GitHub上面有一些支付服务的项目： https://github.com/search?q=%E6%94%AF%E4%BB%98\u0026ref=opensearch\u0026type=repositories 可以支持支付服务的快速开发。\nAI选课助手模块 chatClient介绍：https://springdoc.cn/spring-ai/api/chatclient.html\n请求接收与路由：用户通过Vue3前端界面提出问题，后端RESTful API接收请求。核心的智能路由逻辑会根据预设关键词（如“选课”、“推荐”、“统计”等）判断问题类型。\n业务上下文构建：对于选课相关问题，系统会调用 CourseSelectionService ，通过 JdbcTemplate 高效查询选课数据库，获取课程热度、名额、个人成绩倾向等实时统计数据。\nPrompt工程与模型调用：将查询到的业务数据作为上下文，与预先设计好的系统Prompt（如“你是一名选课顾问…”）进行组装，形成完整的提示信息，然后通过Spring AI调用本地的Ollama (Qwen2:7b)模型。\n响应返回：模型生成的个性化建议或通用回答最终通过统一的API返回给前端展示。\n我总觉得代码生成器（Mybatis-Plus，RuoYi代码生成器）的实现方式和这也差不多 首先创建模板（这里是提示词）然后查询表结构数据，再进行模板渲染得到生成的代码\n过程：请求流程：chatClient.call(message) → 调用 OllamaChatClient → 向本地 Ollama 服务发送请求 智能路由：isCourseSelectionQuestion 方法实现业务问题识别，将选课相关问题路由到 BusinessAIService\nchatClient是SpringAi提供的聊天 页面展示： 2025.10.22\n论坛模块 对于论坛模块，学生可以发帖评价课程，教师不能发帖，两者都可以进行评论回复交流 论坛主页展示一些帖子和热门榜单（Redis缓存）【这都是些简单的增删改查】 想到了一个小玩意，在用户进行发布帖子和进行评论的时候，进行敏感词检查。如果内容中包含敏感词 就弹出提示。实现起来挺简单的，让Java后端负责业务逻辑，python负责机器学习，python运行在本地端口，两者通过http进行通信。 详情请看这篇文章 如何实现一个简单的敏感词检测\n","date":"2025-10-15T00:00:00Z","permalink":"https://1parado.github.io/p/%E4%BB%BF%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/","title":"仿教务系统"},{"content":"\r记录一下创建个人博客的过程。欢迎阅读！\n用到的工具：Github Page + Hugo\n参考链接： https://bright9911.github.io/\n","date":"2025-10-14T00:00:00Z","permalink":"https://1parado.github.io/p/github-page--hugo-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%93%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"GitHub page + hugo 搭建一个专属于自己的个人博客"}]