[{"content":"\r\u0026mdash;2025.10.20\n今天是去实习的第一天 新手上班感觉憋不住笑啊（摸鱼的一天） 王哥给我两个压缩包文件让我先看懂公司代码的逻辑是怎么写的 确实到了公司才知道还有好多东西不知道的 纸上学来终觉浅 今天我甚至手忙脚乱到sql脚本都不知道在哪里执行了\u0026hellip; 明天估计要开始慢慢干活了吧 要写一个任务管理模块 王哥说今晚他把数据库和脚手架创建好 明天我可以先自己尝试了 我觉得还挺好的吧 这个实习 而且合同上面签的也是学生出去学习为主 学校有事情 提前七天告知公司就可以了 Nice！ 今天学到的东西：1.sql脚本执行 2.cmd中输ifconfig查看本机ip 3.关闭快速开机能减少运行内存的使用 附图两张： ","date":"2025-10-20T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/","title":"实习经历"},{"content":"\r参考链接： https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis\nRedis是NoSQL数据库，是一种内存数据库。读写速度很快，经常用于分布式缓存方向，存储的是key-value对数据。Redis支持事务，持久化，lua脚本\u0026hellip;\n可以试一下在线编译器写一下redis命令 简单易上手 easy~\nRedis为什么速度快：1.纯内存操作（纳秒级），传统的数据库需要读写磁盘（毫秒级） 2.高效的I/O模型。3.优化的内部数据结构4.简洁高效的通信协议（RESP）. redis适合做缓存不适合做主数据库，因为内存成本高，且redis虽然支持数据持久化但是有数据丢失风险。 其他的分布式缓存：Tendis,KeyDB\u0026hellip;\n选择Redis的原因：1.访问速度快（基于内存） 2.高并发 3. 功能全面（可以作缓存，可以用于分布式锁，限流，消息队列，延时队列\u0026hellip;）\n常见的缓存读写策略：https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html\nRedis 应用【2025.10.20】\n缓存 分布式锁 Redission 做限流工具 Redis+LUA脚本 RRateLimiter实现分布式限流即基于Lua脚本+令牌桶算法 做消息队列 Redis的Stream类型的数据结构更适合做消息队列（但一般用中间件） 做延时队列 内置了延时队列 基于Sorted Set实现 分布式session 利用String或Hash数据结构存储session数据 Redis可以实现全文搜索引擎功能 需要借助RedisSearch（一个基于Redis的搜索引擎模块）：性能更优秀 较低内存占用实现快速索引。\n延时任务（红包过期自动退还）:实现方式：1. redis过期事件监听（不推荐） 2. redission内置的延时队列 减少了丢消息的可能，消息不存在重复消费问题\nredis常见的数据类型：String、List、Set、ZSet、Hash\n","date":"2025-10-19T00:00:00Z","permalink":"https://1parado.github.io/p/redis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"Redis 常见面试题"},{"content":"\r基础知识（hello 算法）\nhttps://www.hello-algo.com/chapter_array_and_linkedlist/array/\n数组：数组元素存储在连续的内存空间中，如果知道数组首地址和某个元素的索引，查找数据很简单，时间复杂度低O(1)，在数组中插入和删除需要移动元素，所以时间复杂度有点高O(N)。数组（静态）的长度是不可变的（ArrayList动态数组，长度未知的数组），如果扩容数组则重新建立一个更大的数组，复制旧数组的元素到新数组中。\n1 2 // 数组初始化 int[] nums = {1,2,3} or int[] nums = new int[3]; 链表：如果数组很大 内存无法提供这么大的连续空间 则可以使用链表这种数据结构。【value,*】， *指针指向下一个节点的内存地址。链表的尾节点指向null。\n1 2 3 4 5 6 初始化链表 节点1 -\u0026gt; 节点2 // 初始化节点 n0 = listNode(1) n1 = listNode(2) // 构建节点之间的引用 n0.next = n1 链表的插入和删除很简单，只需要改变引用即可O（1），但是查询数据的时候，需要从头节点向后遍历直到目标节点O(N)。\n数组和链表采用了相反的存储策略（一个连续，一个不需要连续），因此各种性质和操作效率都呈对立特点。\n链表的种类：单向链表，双向链表，环形链表\n1 2 3 4 5 6 7 /* 双向链表节点类 */ class ListNode { int val; // 节点值 ListNode next; // 指向后继节点的引用 ListNode prev; // 指向前驱节点的引用 ListNode(int x) { val = x; } // 构造函数 } 列表：元素的有序集合，可以基于数组和链表实现。数组实现的列表是一个有长度限制的列表，因此可以用动态数组来实现列表。列表本质是数组，查找元素很快O（1），插入和删除元素O(N). 列表可以拼接。关于列表的数据结构怎么设计的可以看源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 动态数组初始化 import java.util.ArrayList; import java.util.List; List\u0026lt;Integer\u0026gt; dynamicList = new ArrayList\u0026lt;\u0026gt;(); // 空列表 dynamicList.add(1); // 添加元素 dynamicList.add(2); dynamicList.addAll(java.util.Arrays.asList(3, 4, 5)); // 批量添加 //或者 List\u0026lt;Integer\u0026gt; dynamicList2 = new ArrayList\u0026lt;\u0026gt;(10); // 初始容量 10，可自动扩容 // 列表拼接 dynamicList.add(dynamicList2); // 列表排序（进行完列表排序后 可以使用二分查找和双指针算法） Collections.sort(dynamicList2); 搜索算法：\n暴力法：通过遍历数据结构中的每个元素定位目标\n自适应搜索：利用数据的特性（比如有序性）优化搜索过程\n“二分查找”利用数据的有序性实现高效查找，仅适用于数组。时间换空间\n“哈希查找”利用哈希表将搜索数据和目标数据建立为键值对映射，从而实现查询操作。空间换时间\n数组 二分查找 二分查找是一种基于分治法策略的高校搜索算法，利用数据的有序性，每轮缩小范围直到找到目标或者找不到目标。即给指针low和high分别设置搜索目标，目标可能是一个值，也可能是一个范围，最终他们要么找到目标终止循环，要么越过边界终止循环\n二分查找的优点：时间效率高O（logN），不需要额外的空间【哈希算法以空间换时间】\n二分查找的局限性：仅适合有序数组（不要想着先对无序数组排序再用二分查找，因为排序的时间复杂度就已经很高了），不能对链表进行二分查找，不适合数据经常变化的数组。\n1.二分查找 解题思路：数组有序 返回下标（查找元素）\u0026ndash;\u0026gt; 二分法 这里采用左闭右闭区间[low,high]所以while判断的时候是low \u0026lt;= high\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int low = 0; int high = nums.length - 1; int mid = (low + high)/2; // 向下取整 // int mid = low + （high - low） 这种也可以是为了防止溢出， while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; class Solution { public int searc mid = (low + high)/2; }else{ low = mid + 1; mid = (low + high)/2; } } return -1; } } 2.二分查找插入点（无重复元素）\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n犯的问题：粗心把high初始化的时候设置成 nums. length了，2，3，4情况返回值应该是high+1（要想明白为什么是high+1 ？\u0026ndash;\u0026gt;2，3，4情况下，当循环终止时，high指向小于target的元素，low指向大于target的元素，因此插入的索引应该是high + 1）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { // 可能出现的情况四种1.找到nums[mid] = target // 2.没出现 目标值在最前面 // 3.没出现 目标值在最后面 // 4.没出现 目标值在某个区间 // 2 3 4 要保证统一返回 int low = 0; int high = nums.length - 1; int mid = (high + low)/2; while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; mid = (high + low)/2; }else{ low = mid + 1; mid = (high + low)/2; } } return high + 1; // 注意这个是力扣上的题 是找到值就返回索引 } } 二分查找插入点（有重复元素）\n给定一个长度为 的有序数组 nums 和一个元素 target ，数组存在重复元素。现将 target 插入数组 nums 中，并保持其有序性。**若数组中已存在元素 target ，则插入到其左方。**请返回插入后 target 在数组中的索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 二分查找插入点（存在重复元素） */ int binarySearchInsertion(int[] nums, int target) { int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1] while (i \u0026lt;= j) { int m = i + (j - i) / 2; // 计算中点索引 m if (nums[m] \u0026lt; target) { i = m + 1; // target 在区间 [m+1, j] 中 } else if (nums[m] \u0026gt; target) { j = m - 1; // target 在区间 [i, m-1] 中 } else { j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中 } } // 返回插入点 i return i; } 3.找起始位置和终止位置 没思路(老老实实写两个函数 不要想着函数复用和其他方法了 边界处理太难想了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int[] searchRange(int[] nums, int target) { int left = searchLeft(nums, target); int right = searchRight(nums, target); if (left != -1 \u0026amp;\u0026amp; right != -1) { return new int[]{left, right}; } return new int[]{-1, -1}; } public int searchLeft(int[] nums, int target) { int low = 0, high = nums.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (nums[mid] \u0026gt;= target) { high = mid - 1; } else { low = mid + 1; } } if (low \u0026lt; nums.length \u0026amp;\u0026amp; nums[low] == target) return low; return -1; } public int searchRight(int[] nums, int target) { int low = 0, high = nums.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (nums[mid] \u0026lt;= target) { low = mid + 1; } else { high = mid - 1; } } if (high \u0026gt;= 0 \u0026amp;\u0026amp; nums[high] == target) return high; return -1; } } 移除元素 双指针：设计不同移动速度，不同间距，不同方向的两个指针进行操作 解决问题。指向相同序列一般有快慢指针，首尾指针，固定间距指针等。指向不同序列有归并排序。可以用来求链表的中点、链表是否成环、移除数组中多余的元素（原地移除）、归并排序 等\n1.移除元素（快慢指针法）\n思路：我一想到双指针脑子里面总是会想让i指向0，j指向i+1或者就是i指向0，j指向length-1.实际上的情况比这更复杂，不能用这种惯性思维来做题。（这道题是看了代码随想录的演示动画自己写的while循环 其实for循环比这个简单）\n首先确定指针表示的含义 i是指向新的子数组的下标，新数组中不允许有val j是用于找到非val值用于交换的元素 初始化：i=j=0 在循环中i和j的变化分情况讨论 nums[i]！=val时 不需要交换 只需要i和j同时向后移动即可 nums[i]=val时 分两种情况 nums[j]=val时，需要让j自己移动到不为val的地方，变成nums[j]!=val的情况 然后进行交换 交换后i和j再同时移动 循环终止条件：当j到达length - 1 的时候循环终止\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int removeElement(int[] nums, int val) { // i指针指向的数组中不允许有val j指针用于找到非val的元素 // 指针初始化位置 i=j=0 int i = 0; int j = 0; while(j \u0026lt;= nums.length - 1){ if(nums[i]==val){ if(nums[j]!=val){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j++; }else{ j++; } }else{ i++; j++; } } return i; } } // 第二种解法（推荐） class Solution { public int removeElement(int[] nums, int val) { int i = 0; int j = 0; while(j\u0026lt;nums.length){ if(nums[j]!=val){ // 注意这个地方的执行顺序 如果先让i++ 然后再覆盖的话就会出现溢出错误 因为这是数组 i实际是个数字不是指针不会发生指针溢出的情况 如果让数组取nums[length]才会报错 nums[i] = nums[j]; i++; } j++; } return i; } } 2.26. 删除有序数组中的重复项 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int removeDuplicates(int[] nums) { int i = 0;//slow int j = 0;//quick while(j\u0026lt;nums.length){ if(nums[i]!=nums[j]){ i++; nums[i] = nums[j]; } j++; // 这一步是每次都会执行的，并不是执行完if语句就不执行了 } return i+1; } } date: 2025-10-19\n283. 移动零 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public void moveZeroes(int[] nums) { int i=0; int j=0; while(j\u0026lt;nums.length){ if(nums[j]!=0){ nums[i] = nums[j]; i++; } j++; } //比如初始数组是【1，0，2，0，3】 结束时数组是【1，2，3，0，3】所以需要对后面的进行赋零操作 要想清楚结束的时候i指向哪 while(i\u0026lt;nums.length){ nums[i] = 0; i++; } } } 977. 有序数组的平方 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int[] sortedSquares(int[] nums) { // 首尾双指针 int i = 0; int j = nums.length-1; int k = 0; int[] nums2 = new int[nums.length]; while(i\u0026lt;=j){ if(nums[i]*nums[i] \u0026lt;= nums[j]*nums[j]){ nums2[k] = nums[i]*nums[i]; i++; }else{ nums2[k] = nums[j]*nums[j]; j--; } k++; } Arrays.sort(nums2); // 无返回值 直接对原数组进行操作 return nums2; } } 209. 长度最小的子数组 - 力扣（LeetCode）\n滑动窗口O（N）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 第一种解法 时间复杂度和空间复杂度都是O(N) 使用了滑动窗口和动态数组 可以不用动态数组而是用一个变量来记录min_length class Solution { public int minSubArrayLen(int target, int[] nums) { int i = 0; int sum = 0; ArrayList\u0026lt;Integer\u0026gt; length_list = new ArrayList\u0026lt;\u0026gt;(); // for(int j = 0;j\u0026lt; nums.length; j++){ sum += nums[j]; // 先大范围找 移动j 在满足粗略的条件之后再缩小范围 移动i【i和j都是只增不减的 双循环的时候j会变小】 while(sum \u0026gt;= target){ int length = j - i + 1; length_list.add(length); sum -= nums[i]; i++; } } if(length_list == null || length_list.isEmpty()){ return 0; }else{ int min_length = Collections.min(length_list); return min_length; } } } 59. 螺旋矩阵 II - 力扣（LeetCode）\n主要是考察边界条件的判断\n区间和: 可以用sum数组保存前n项和 如果想计算下标2-5的区间和 可以通过前5项和-前二项和\n链表 \u0026mdash;2025.10.20\n链表节点类\n1 2 3 4 5 6 7 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } 链表删除节点 直接让next指针被删除节点的下一个节点即可 Java有自己的回收机制 被删除的节点会自动回收\n关于链表的Java语法都忘完了 删除元素就是 current.next = current.next.next; 还需要注意什么时候创建的是节点 什么时候创建的是指针\n203. 移除链表元素 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode removeElements(ListNode head, int val) { // 设置一个虚拟头节点vir 以及一个当前指针cur用来遍历 ListNode vir = new ListNode(); vir.next = head; //vir放在head前面作为虚拟头节点 ListNode cur = vir; // cur指针指向当前遍历的节点 while(cur.next!=null){ //考虑清除循环终止条件 当cur遍历到最后一个节点 即cur.next == null 时终止循环 if(cur.next.val == val){ cur.next = cur.next.next; //如果cur指向的节点值为val 则移除 }else{ cur = cur.next; // 移动cur到下一个节点 } } // 返回值难以确定时 考虑极端情况试试 // 当首节点为val时 就会被删除 所以vir.next是正确的 而不是head return vir.next; } } 707. 设计链表 - 力扣（LeetCode）\n在链表类中还需要设置链表的size 和 head 以及初始化链表 最关键的就在于如何初始化 如何循环 以及如何结束循环\n2025.10.21\n206. 反转链表 - 力扣\n反转链表（也不会 算法好难！！！\u0026ndash;果然还是安静的时候写算法题有效果）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { // 双指针 ListNode cur = head; // 当前节点指针 ListNode pre = null; // 当前节点指针的前一个节点 // （我想的太多了 我想着如果转换方向之后 后一个节点就找不到了 可以用临时temp记录一下就好了啊！） while(cur != null){ ListNode temp = cur.next; // 记录一下当前节点的下一个节点的位置 cur.next = pre; pre = cur; // 然后让pre向后移动 即指向cur cur = temp; // 让cur指向temp } return pre; } } 24. 两两交换链表中的节点 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //我想的是设置一个flag 来判断是否需要交换 然后用一个temp表示cur节点的后一个节点 用于交换 即在循环体中 1.temp = cur.next临时保存 // 2.cur.next-\u0026gt;temp.next 3. temp.next-\u0026gt;cur 但是有错误！！！ 2-1-3-5 4-3-5 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next ==null){ // 链表为空/链表中只有一个元素 return head; } // 这个代码是错误的 结果是2-1-3-5 4-3-5 ListNode cur = head; while(cur.next !=null ){ ListNode temp = cur.next; // 这是用temp记录后一个节点不行 试试用temp记录pre cur.next=temp.next; temp.next=cur; cur = cur.next; } return cur; } } 错误代码2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next ==null){ // 链表为空/链表中只有一个元素 return head; } ListNode vir = new ListNode(); vir.next = head; ListNode cur = head; ListNode pre = vir; while(cur.next !=null \u0026amp;\u0026amp; cur.next.next!=null){ pre.next = cur.next; cur.next = cur.next.next; pre.next.next = cur; pre = pre.next; cur = cur.next; } return vir.next; } } 19 删除倒数第N个节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 解题思路（Mine）：先找到这个节点是正数第几个位置 然后找到其前置节点 进行删除操作 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode vir = new ListNode(); vir.next = head; ListNode cur = vir; int size = 0; // 遍历一遍得到链表的size while(cur.next != null){ size++; cur = cur.next; } int z = size - n + 2; //倒数第n是正数第size - n + 1 这里的z = size - n + 1是其前节点 ListNode vir2 = new ListNode(); vir2.next = head; ListNode cur2 = vir2; int count = 1; // 要注意这里的count是从1开始的 是指链表中的第几个节点 while(cur2.next != null){ count++; if(count == z){ cur2.next = cur2.next.next; return vir2.next; } cur2 = cur2.next; } return vir2.next; } } ","date":"2025-10-17T00:00:00Z","permalink":"https://1parado.github.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/","title":"代码随想录(长期更新)"},{"content":"\rRuoYi-Vue-Pro: https://doc.iocoder.cn/quick-start/\n后端版本:我下载的mini版本的，只有一些简单的功能，其中的一些功能是受限的 https://github.com/YunaiV/ruoyi-vue-pro\n前端版本：Vue3 + element-plus 版本 https://github.com/yudaocode/yudao-ui-admin-vue3/\n按照RuoYi配置文档一步一步来其实挺好搭建的，主要是要先配置环境。\n","date":"2025-10-16T00:00:00Z","permalink":"https://1parado.github.io/p/ruoyi%E6%A1%86%E6%9E%B6/","title":"RuoYi框架"},{"content":"\r⚫ 找论文的一些网站（有些网站要翻墙） Google scholar⭐⭐⭐⭐⭐： 可以配合谷歌插件Easy scholar直接显示期刊的等级和影响因子 2.Web of science⭐⭐⭐\n3.Sciencedirect⭐⭐⭐\n4.Ieeexplore⭐⭐⭐\n5.Arxiv⭐⭐预印的期刊，文章比较新但可能有小错误\n6.CNKI 中文知网⭐⭐\n⚫ 文献管理工具： Zotero + 翻译插件: https://blog.csdn.net/xiaoningaijishu/article/details/151042814\nIma腾讯推出的个人知识库（英文不好的强烈推荐！）把论文上传到知识库中，然后全局翻译，翻译的很准确，而且可以根据知识库进行提问。\n小绿鲸（我没用过，看师兄用过）: https://www.xljsci.com/\n⚫ 笔记软件： Notion，Obsidian，Ima，Typora, Cherry studio\u0026hellip;推荐Obisidian 轻量化（但其实没有做笔记的习惯的话不下载也可以）\n⚫ 用于论文写作的一些工具 overleaf是一款在线编写latex格式的论文写作软件，可以配合浏览器插件Grammarly检查语法错误 https://app.grammarly.com/\noverleaf模板: https://cn.overleaf.com/latex/templates 点 Journal Article 找对应的论文模板格式下载压缩包 导入到overleaf即可编写操作\n习惯用Vs code的可以在vscode中下载overleaf的插件 直接在vscode中编写也可:https://zhuanlan.zhihu.com/p/29808221714\n⚫ 好用的网站： 表转latex格式 https://tablesgenerator.com/\nlatex公式在线编写： https://www.latexlive.com/home\nCanva做汇报ppt: https://www.canva.cn/\nBoardmix做思维导图: https://boardmix.cn/app/home\nProcesson做流程图: https://www.processon.com/\nVison也可以画流程图，可以导出矢量图.svg格式，适合放在文章里面做流程图:https://blog.csdn.net/laowangpython/article/details/147465427\n⚫ AI工具： 我常用的ai就是下面这些，主推GPT和Grok，其他的可以在论文写作的时候，优化论文表达的时候用。【小技巧：可以自己写中文初稿，然后让gpt翻译成英文，再截图让gpt生成latex格式，直接复制到overleaf里即可，英文好的话直接用英文写也可以】\n1.chatgpt: https://chatgpt.com/\n2.grok: https://grok.com/\n3.kimi: https://www.kimi.com/\n4.deepseek: https://chat.deepseek.com/\n每个课题组的研究方向不一样，发论文的难度也不一样，下面只是我的研究过程： 先确定研究方向，然后读最新的几篇综述（最好选英文文献，中文也可以），然后找一篇感觉能复现出来的文章进行复现（可以发邮件给作者看看能不能要到源码，最好多问几个，真的有人愿意给的/用AI帮忙），然后在该文章的基础上想一下有没有可以新增的点（看论文的未来展望/和其他论文模型进行融合），一篇好的论文需要天时地利人和，EI会议随便写，好多都是论文A的模块 + 论文B的模块整合到一起得到自己的创新模型。\n以我们组的研究方向为例：网络弹性量化（Cyber resilience quantification），在文献搜索网站上面搜关键词，然后读几篇综述，大致了解一下网络弹性评估包括车联网，信息关键基础设施网络，电网，无人机集群网络\u0026hellip;.本来是研究车联网的，然后组会汇报两次无人机相关文章，莫名其妙研究方向变成无人机了，也算找到了研究领域:无人机集群网络弹性评估。然后读无人机集群网络弹性评估的文章，暑假开始，老师让复现文章，刚开始一直没复现出来，联系好多文章作者要源码，最后有一个学长给了我他的部分代码，然后复现他的这篇文章，在他的文章基础上加了一些模块解决了一些现有研究领域没有解决的问题。（文章还没发，不敢把论文放网上）满打满算两个多月写一篇EI是够用的。\n","date":"2025-10-16T00:00:00Z","permalink":"https://1parado.github.io/p/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/","title":"科研论文写作"},{"content":"\r参考链接：https://javaguide.cn/database/mysql/mysql-questions-01.html\n📚 数据库基础 ER图 提供实体（方块） 属性（椭圆）和联系（菱形）的方法 关系：1对1，1对多，多对多\u0026hellip; 在创建项目之前应该先构建好数据库 并且绘制ER图来理清数据之间的关系。\n数据库范式：1NF（属性不可再分）,2NF（在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖）,3NF（在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖），BCNF（在3NF的基础上 去除属性见不必要的函数依赖）\n主键：唯一标识一个元组（行）不重复不为空，一个表只有一个主键\n外键：与其他表建立联系 外键是另外一个表的主键 可以重复可以为空 一个表可以有多个外键\n一般不推荐外键：1.增加了复杂性 2.增加了维护外键的工作量 3.对数据库分表不友好\n外键的好处：1.保证数据一致性和完整性 2.级联操作简单\ndrop 删除表结构 turncate 清空表数据 delete使用where限定删除某一行数据/清空表数据\n执行速度drop\u0026gt; turncate \u0026gt;delete\n数据库设计：需求分析-ER图-ER图转为表-选取数据库和存储结构-编程测试试和运行-运行和维护\n关系型数据库:如 mysql 支持事务的四大属性：ACID属性（原子性，一致性，隔离性，持久性）\n非关系型数据库: 如redis 天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。非关系型数据库比较灵活，性能高，可扩展性强\n字符集：GBK,ASCII,UTF8\u0026hellip; MySQL8.0默认字符集utf8mb4\nDDL数据定义语言: 定义数据库对象 CREATE、ALTER、DROP\nDML数据操纵语言 : 访问数据，因此其语法都是以读写数据库为主 CRUD\nDCL数据控制语言 : 控制用户的访问权限 授予权限GRANT、收回权限REVOKE\nTCL事务控制语言：管理数据库中的事务 , 提交事务commit 回滚事务 rollback\n索引⭐【面试被问到了】\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构\n分为：唯一索引 主键索引 聚集索引 哈希索引\nhttps://javaguide.cn/database/mysql/mysql-index.html\nsql（结构化查询语言） 语法常见面试总结可以去牛客上看 也可以刷力扣上的sql 题 这里我就不着重看了 之后刷sql题的时候再看\n容易混淆的点：\nDecimal 可以存精确的小数 Float / Double 只能存近似的小数 DateTime 没有时区信息 八字节存储 TimeStamp 和时区有关 四字节存储 Null 1.null表示缺失的值 2.任何值与null比较结果都是null 3.有些聚合函数忽略null “ ” 1.空字符串 2.“ ” 可以进行比较，如 “ ” = “ ”结果为true 3. 聚合函数不忽略 MySQL执行流程：\n连接器（进行身份验证） 分析器（进行词法分析 和 语法分析） 优化器（按照MySQL认为最优的方案执行） 执行器（执行语句 从存储引擎返回数据） **存储引擎⭐（InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，只有InnoDB支持事务） 存储引擎采用插件式架构 ，基于表结构而不是数据库\nMySQL 日志⭐\n常见的日志分类:错误日志，查询日志，慢查询日志（可以结合 EXPLAIN 分析查询执行计划，优化索引或 SQL 结构，可用于性能优化），二进制日志（主从复制），回滚日志，重做日志（保证事务的持久性）\u0026hellip;\nMySQL事务：逻辑上的一组操作要么都执行要么都不执行。事务分为扁平事务（最简单的情况），嵌套事务，分布式事务\u0026hellip; 事务的四大属性ACID. 事务的目的就是为了保证数据的一致性。\n并发事务带来的问题：脏读，不可重复读，幻读，丢失修改（四种问题基本概念是什么？如何解决？）\n并发事务的控制方式：\n锁，通过读写锁来显式控制共享资源 分为表级锁（对整表加的锁）和行级锁（对索引字段加的锁），MyISAM 仅仅支持表级锁，InnoDB两者均支持。无论是表级锁和行级锁都存在共享锁S和排他锁X。意向锁可以来快速判断是否可以对某个表使用表锁，从而有了意向共享锁IS和意向排他锁IX MVCC（多版本并发控制）即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。 事务隔离级别（级别越高，数据一致性越好，但并发性能可能越低）：1.读未提交 2.读已提交 3.可重复读（MySQL默认的隔离级别） 4.可串行化。 MySQL 的隔离级别基于锁和 MVCC 机制共同实现的\n当前读和快照读\n当前读 = 当前最新数据 + 会加锁 → “最新、可能被阻塞”\n快照读 = 事务快照 + 不加锁 → “旧版本、不会被阻塞”\nMySQL调优⭐\nhttps://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html\nMySQL可以存文件（文件转为二进制文件存入MySQL），但是影响数据库性能占用太多存储空间。可以用云服务厂商提供的对象存储如OSS\u0026hellip;也可以用MinIO开源项目实习分布式文件服务。\nhttps://www.51cto.com/article/716978.html\nMySQL性能优化：慢查询日志找 SQL → Explain 看执行计划（分析性能） → 索引优化/表结构优化\u0026hellip; → 锁和 IO 分析 → SQL 重写 → 测试验证\n读写分离：读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。\n如何实现：主数据库和从数据库数据实时同步（主从复制），写请求交给主数据库处理，读数据库交给从数据库处理。\n主从复制：主数据库的数据变化写入二进制日志，从库链接主库，主库创建I/O线程发送二进制日志给从库，从库将二进制日志写入中继日志（Relay log）然后从库的sql线程读取中继日志实现主从数据实时同步（可能会发生主从同步延迟）\n第一种实现方式：代理方式\n在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。\n第二种实现方式：组件方式\n引入第三方组件来帮助我们读写请求。\n分库分表：如果一张表的存储数据量太大就要分库分表。分库分为水平分库（按照数据划分，行划分）和垂直分库（按照业务划分，属性划分）分表与分库同理。分库分表之后需要解决事务问题，分布式id问题，join操作问题\n冷热数据：热数据是指经常被访问和修改且需要快速访问的数据，冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。可以按照时间和访问频率划分。\n延时双删⭐【面试被问到了】（保证数据一致性）：首先删除redis中的缓存数据，然后更新数据库中的数据，让当前线程休眠一段时间，唤醒之后再次删除redis的缓存数据。\n2025.10.19\nMySQL高性能优化规范建议总结（了解即可） 数据库命名要规范 所有表使用InnooDB存储引擎 数据库和表的字符集统一使用utf8 单个表的数据量大小尽量在500万之内，再大可以考虑分库分表。对于日期类型用Datatime或timestamp 不要用字符串存储。可以通过查询MySQL的慢查询日志发现需要进行优化的sql语句。对于超100万行的批量操作（插入，更新，删除）要分批多次进行操作，因为大批量操作可能会造成主从延迟。\n重点【重新看一下】 索引：索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。常见的索引结构：B-Tree索引、B+树索引、Hash索引、红黑树索引\u0026hellip; InnoDB和MyISAM都选择B+树作为索引结构. 索引的优缺点：\n优点：1.查询速度快减少磁盘I/O次数 2.保证数据的一致性（唯一索引）3.可以加快排序和分组\n缺点：创建和维护耗时，占用存储空间,当数据量太小的时候全表扫描速度会比索引快。\n索引： 1.按照数据结构分类：B-Tree索引、B+树索引、Hash索引、红黑树索引\u0026hellip; 2.按照底层存储方式分类：聚集索引和非聚集索引 3.应用维度分类：主键索引，唯一索引，普通索引，覆盖索引\nB数和B+树的区别：1. B树的每个节点都存了key和data，B+树的data只存在叶子节点。非叶子节点仅存在key，可以让B+树更低，磁盘I/O操作次数更少。2. B+树所有叶子构成有序链表按照主键排序遍历全部记录 支持范围查找。\n主键索引：一个表只有一个主键索引，主键索引不能为null，不能重复。如果设计表的时候没有符合的字段（唯一且不为null），InnoDB会自动创建一个自增字段作为主键索引。\nEXPLAIN 分析执行计划 通过查询优化器对语句进行分析 找出最优的查询方法 并显示对应的信息\nMySQL三大日志：\n二进制日志（Binary log）：记录了所有对数据库的DDL和DML操作。可以用于数据备份，主从复制 ","date":"2025-10-15T00:00:00Z","permalink":"https://1parado.github.io/p/mysql-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"Mysql 常见面试题"},{"content":"\r2025.10.15 这是创建的 思维导图\n2025.10.21\n登录模块 登录鉴权 ：该项目采用SpringAOP + 自定义注解@RoleRequire实现RBAC鉴权\n现有的登录鉴权方式：\nSpringSecurity+RBAC模型+JWT实现认证与授权 SpringBoot + Sa-Token + MyBatis + MySQL + Redis 实现用户鉴权、角色管理、权限管理 Apache Shiro 是一个轻量级的安全框架，适合需要简单易用的权限管理的项目 自定义 定义用户、角色、权限三张表，设计合理的关联关系， 使用拦截器或 AOP 实现权限校验逻辑。根据业务需求设计动态权限分配机制。 JWT实现无状态认证（不需要服务器存储用户的会话状态），一个JWT包括头部，载荷，签名。\n过程：用户登录认证时，服务端验证用户身份，成功的话，服务端生成JWT返回给客户端，客户端在之后的请求中将JWT放在请求的头部（Authorization）,然后服务端通过解析JWT从而确定用户的身份和权限\n双token机制实现无感刷新：分为两种token 一种是access token（访问令牌）短期有效 ，一种是 refresh token（刷新令牌），长期有效。\n过程：客户端登录，认证成功，服务端签发access_token（返回给前端）和refresh token（存入cookie） 之后，客户端访问接口都带着access_token 当access_token过期之后 客户端发送给refresh token给服务端 验证通过则生成新的access token和refresh token，从而实现无感刷新\n双 Token 认证机制：从原理到实践的完整实现双 Token 认证机制：从原理到实践的完整实现 在现代 Web 应用中 - 掘金\n登录模块展示：首先进入登录页面： 然后根据角色的不同，进入不同的主页，系统分为三种角色Admin,Teacher,Student 秒杀抢课模块 1.获取动态路径 使用UUID + MD5生成一个唯一标识符 结合前端URL生成动态路径 避免被脚本直接访问\n2.实现限流保护 使用令牌桶实现限流保护（ Redis + 令牌桶算法），这里创建一个工具类TokenBucket，里面的参数包括桶的最大容量，间隔几秒补充几个令牌，当前可用令牌数\u0026hellip;方法包括令牌补充refill和获取令牌逻辑try Acquire 从而实现限流。\n还可以利用redission实现分布式限流 基于 Redisson 的分布式限流实战：令牌桶算法的优雅实现 - 你小志蒸不戳 - 博客园，比如保护AI访问的API\n其他限流方式：固定窗口、滑动窗口、漏桶限流和令牌桶限流算法\n检验动态路径（在获取动态path的时候会将动态path存入Redis，用于此时的动态路径校验） 检查当前用户是否重复秒杀 (幂等控制) 通过三级缓存实现 本地缓存采用Caffine/Guava 二级缓存采用Redis 三级缓存采用数据库 当发现任意一级的数据库中已经有选课记录了 就返回重复秒杀异常 幂等性指的是一个操作，无论执行多少次，都能得到相同的结果，即它不会因为执行多次而影响系统的状态。这在处理网络请求、数据库操作等场景中尤为重要，例如在订单支付、消息推送等操作中，即使因为网络延迟或其他原因导致多次请求，也应保证操作只执行一次，避免重复处理。\n进入秒杀的核心阶段 Redis + Lua脚本 + RocketMQ 实现 库存预减 + 异步入队\n从零开始实现秒杀系统（三）：RocketMQ消息队列篇 - Xun\u0026rsquo;s Blog\nLua脚本进行双重判断，首先判断是否售罄标志，然后再判断库存预减之后的库存数量，并且在脚本中实现库存减1的操作 如果成功返回1 失败返回 0.Lua脚本返回成功，系统发送消息到消息队列（RocketMQ）采用事务消息机制保证数据的最终一致性。\n生产者发送半消息 本地事务创建选课记录（订单） 根据事务的执行结果通知Broker是投递该消息还是丢弃该消息 消费者异步从MQ中消费信息 完成后续业务。\n页面展示： 首先填写预选课信息（类似于商城系统的购物车），然后查看选课信息（普通选课和秒杀抢课） 如果用户是首次抢课且库存充足，则显示抢课成功 如果用户重复抢课则提醒请勿重复秒杀 Admin端新增抢课信息 当学生张三选过课程之后，该课程已经“售罄”了 接下来用李四来选课会提醒库存不足 抢课失败 之后可以考虑用jmeter测试高并发场景下的抢课情况。\n支付模块 支付过程：\n用户点击缴费 进入AliPayController 用请求头中的Authorization进行身份验证 用请求体中的PaymentPO来生成缴费信息【前端会收集页面信息 当用户点击缴费按钮就会构建PaymentPO写入请求体中传给后端】 初始化订单信息 订单的状态初始化为0 标识未缴费 每个订单有一个唯一的订单号 使用创建好的支付工具类PayUtil 调用支付宝接口完成支付流程\nPayUtil中的核心方法即发起支付和查询支付结果方法： 发起支付：1.初始化支付宝客户端 2. 创建支付请求 3.设置业务参数 4.发起请求并且返回支付结果 查询支付结果：创建查询请求-执行查询-处理查询结果\n结果展示： 学生点击缴费之后，跳转到支付页面 GitHub上面有一些支付服务的项目： https://github.com/search?q=%E6%94%AF%E4%BB%98\u0026ref=opensearch\u0026type=repositories 可以支持支付服务的快速开发。\nAI选课助手模块 chatClient介绍：https://springdoc.cn/spring-ai/api/chatclient.html\n请求接收与路由：用户通过Vue3前端界面提出问题，后端RESTful API接收请求。核心的智能路由逻辑会根据预设关键词（如“选课”、“推荐”、“统计”等）判断问题类型。\n业务上下文构建：对于选课相关问题，系统会调用 CourseSelectionService ，通过 JdbcTemplate 高效查询选课数据库，获取课程热度、名额、个人成绩倾向等实时统计数据。\nPrompt工程与模型调用：将查询到的业务数据作为上下文，与预先设计好的系统Prompt（如“你是一名选课顾问…”）进行组装，形成完整的提示信息，然后通过Spring AI调用本地的Ollama (Qwen2:7b)模型。\n响应返回：模型生成的个性化建议或通用回答最终通过统一的API返回给前端展示。\n我总觉得代码生成器（Mybatis-Plus，RuoYi代码生成器）的实现方式和这也差不多 首先创建模板（这里是提示词）然后查询表结构数据，再进行模板渲染得到生成的代码\n过程：请求流程：chatClient.call(message) → 调用 OllamaChatClient → 向本地 Ollama 服务发送请求 智能路由：isCourseSelectionQuestion 方法实现业务问题识别，将选课相关问题路由到 BusinessAIService\nchatClient是SpringAi提供的聊天 页面展示： ","date":"2025-10-15T00:00:00Z","permalink":"https://1parado.github.io/p/%E4%BB%BF%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/","title":"仿教务系统"},{"content":"\r记录一下创建个人博客的过程。欢迎阅读！\n用到的工具：Github Page + Hugo\n参考链接： https://bright9911.github.io/\n","date":"2025-10-14T00:00:00Z","permalink":"https://1parado.github.io/p/github-page--hugo-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%93%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"GitHub page + hugo 搭建一个专属于自己的个人博客"}]