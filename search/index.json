[{"content":"\r实现过程：1.创建机器学习模型 通过（朴素贝叶斯 + TF-IDF 向量化）实现文本二分类 当文本中包含敏感词的时候返回1 否则返回0 这里我创建了一个sensitive_detector.py文件。首先自定义输入一些敏感词数据库，然后进行文本向量化，将文字转为数值特征，然后用MultinomialNB模型进行训练 最后保存模型（.pkl文件），让该模型运行在本地的一个端口上\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 from flask import Flask, request, jsonify from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB import jieba import joblib app = Flask ( __name__ ) # === 1. 准备数据 === texts = [ # 正常内容 \u0026#34;我爱学习人工智能\u0026#34;, \u0026#34;今天真开心\u0026#34;, \u0026#34;你好，朋友\u0026#34;, \u0026#34;祝你生活愉快\u0026#34;, \u0026#34;我喜欢听音乐\u0026#34;, \u0026#34;看电影真有趣\u0026#34;, \u0026#34;一起打游戏吧\u0026#34;, \u0026#34;美丽的风景让人心情愉快\u0026#34;, # 敏感内容 \u0026#34;买枪支弹药请加我\u0026#34;, \u0026#34;出售身份证\u0026#34;, \u0026#34;这是黄色网站链接\u0026#34;, \u0026#34;成人内容免费看\u0026#34;, \u0026#34;黄色小说推荐\u0026#34;, \u0026#34;如何制作炸弹\u0026#34;, \u0026#34;赌博网站登录入口\u0026#34;, \u0026#34;免费看黄片\u0026#34; ] labels = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1] # 0=正常，1=敏感 # === 2. 中文分词函数 === def chinese_tokenizer(text): return jieba.lcut ( text ) # === 3. 向量化 + 训练模型 === vectorizer = TfidfVectorizer ( tokenizer=chinese_tokenizer ) X = vectorizer.fit_transform ( texts ) model = MultinomialNB () model.fit ( X, labels ) # === 4. 保存模型（方便部署） === joblib.dump ( vectorizer, \u0026#39;vectorizer.pkl\u0026#39; ) joblib.dump ( model, \u0026#39;model.pkl\u0026#39; ) @app.route ( \u0026#34;/predict\u0026#34;, methods=[\u0026#34;POST\u0026#34;] ) def predict(): data = request.get_json () text = data.get ( \u0026#34;text\u0026#34;, \u0026#34;\u0026#34; ) X_new = vectorizer.transform ( [text] ) pred = model.predict ( X_new )[0] return jsonify ( {\u0026#34;sensitive\u0026#34;: bool ( pred )} ) if __name__ == \u0026#34;__main__\u0026#34;: app.run ( port=5001 ) 运行上述py文件：\n接下来可以通过postman等接口测试工具测试一下，当发布敏感词的时候会显示true 无敏感词的时候显示false。\n运行项目进行检测：\n到此 就实现了一个简单的文本敏感词检测功能 可以用于论坛模块的发帖和评论功能中。后续可以扩展敏感词库，敏感词库可以从开源中文敏感词库（如“百度敏感词库”、“naughty-words 中文版”）获取\u0026hellip;\n","date":"2025-10-22T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%8F%E6%84%9F%E8%AF%8D%E6%A3%80%E6%B5%8B/","title":"如何实现一个简单的敏感词检测"},{"content":"\r对于某些需要隐私保护的文件或者内容不太适合用在线翻译软件，因此可以在自己电脑上实现一个翻译器\n首先看一下百度翻译的页面包括好多功能，文本翻译，图片翻译\u0026hellip; 今天先简单实现一下文本翻译 对于一个翻译系统其实很简单 只要前端点击翻译按钮 后端能返回响应结果即可 关键在于如何返回正确的结果 这里我先创建了一个翻译器V1 用于测试前后端联动是否可以打通\n如果想要识别语言并且返回正确结果 可以有两种方法 一种是调用厂家的API 一种是调用大模型，提供prompt让大模型当你的翻译官即可\n可以在百度翻译开放平台获取API和密钥\n可以在TranslationService中调用API实现调用接口进行翻译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 package com.example.translation.service; import org.springframework.stereotype.Service; import java.net.URLEncoder; import java.nio.charset.StandardCharsets; import java.security.MessageDigest; import java.util.UUID; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; @Service public class TranslationService { // 替换为你自己的百度翻译 AppID 和密钥 private static final String APP_ID = \u0026#34;你的AppID\u0026#34;; private static final String SECURITY_KEY = \u0026#34;你的密钥\u0026#34;; public String translate(String text, String targetLang) { try { String from = \u0026#34;auto\u0026#34;; String to = getBaiduLangCode(targetLang); String salt = UUID.randomUUID().toString(); String sign = md5(APP_ID + text + salt + SECURITY_KEY); String encodedText = URLEncoder.encode(text, StandardCharsets.UTF_8); String urlStr = String.format( \u0026#34;https://fanyi-api.baidu.com/api/trans/vip/translate?q=%s\u0026amp;from=%s\u0026amp;to=%s\u0026amp;appid=%s\u0026amp;salt=%s\u0026amp;sign=%s\u0026#34;, encodedText, from, to, APP_ID, salt, sign); URL url = new URL(urlStr); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\u0026#34;GET\u0026#34;); conn.connect(); BufferedReader reader = new BufferedReader( new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8)); StringBuilder result = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { result.append(line); } reader.close(); conn.disconnect(); // 简单解析返回内容 String res = result.toString(); int start = res.indexOf(\u0026#34;\\\u0026#34;dst\\\u0026#34;:\\\u0026#34;\u0026#34;); if (start \u0026gt; 0) { int end = res.indexOf(\u0026#34;\\\u0026#34;}\u0026#34;, start); return res.substring(start + 7, end).replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;).replace(\u0026#34;\\\\u\u0026#34;, \u0026#34;u\u0026#34;); } return \u0026#34;翻译失败：\u0026#34; + res; } catch (Exception e) { e.printStackTrace(); return \u0026#34;翻译错误：\u0026#34; + e.getMessage(); } } private String getBaiduLangCode(String target) { return switch (target.toLowerCase()) { case \u0026#34;english\u0026#34; -\u0026gt; \u0026#34;en\u0026#34;; case \u0026#34;japanese\u0026#34; -\u0026gt; \u0026#34;jp\u0026#34;; case \u0026#34;korean\u0026#34; -\u0026gt; \u0026#34;kor\u0026#34;; case \u0026#34;french\u0026#34; -\u0026gt; \u0026#34;fra\u0026#34;; case \u0026#34;german\u0026#34; -\u0026gt; \u0026#34;de\u0026#34;; default -\u0026gt; \u0026#34;en\u0026#34;; }; } private String md5(String input) throws Exception { MessageDigest md = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;); byte[] array = md.digest(input.getBytes(StandardCharsets.UTF_8)); StringBuilder sb = new StringBuilder(); for (byte b : array) { sb.append(String.format(\u0026#34;%02x\u0026#34;, b \u0026amp; 0xff)); } return sb.toString(); } } 由于我电脑上面下载的有Ollama 所以我选择调用本地大模型的接口服务 实现翻译功能 不知道的同学可以下载一下ollama 然后下载一个模型 建议qwen:0.5b 即可 其他模型占用内存太大 输入ollama list 看一下本地已经下载了哪些模型 打开Windows终端 输入命令 ollama run qwen2:0.5b\n给模型设置提示词然后让后端服务调用本地大模型即可实现翻译功能\n1 2 3 Map\u0026lt;String, Object\u0026gt; body = new HashMap\u0026lt;\u0026gt;(); body.put(\u0026#34;model\u0026#34;, \u0026#34;qwen2:0.5b\u0026#34;); body.put(\u0026#34;prompt\u0026#34;, \u0026#34;请将以下文本翻译成英文：\u0026#34; + text); 接下来启动服务 看一下效果 遇到的问题：在运行的时候 我的8080端口号被占用了 可以换一个端口号 也可以将启动的服务关闭 这里我选择关闭现有服务 然后重新启动 监听8080端口\n","date":"2025-10-22T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E7%BF%BB%E8%AF%91%E5%99%A8/","title":"实现一个本地翻译器"},{"content":"\r\u0026mdash;2025.10.20\n今天是去实习的第一天 新手上班感觉憋不住笑啊（摸鱼的一天） 王哥给我两个压缩包文件让我先看懂公司代码的逻辑是怎么写的 确实到了公司才知道还有好多东西不知道的 纸上学来终觉浅 今天我甚至手忙脚乱到sql脚本都不知道在哪里执行了\u0026hellip; 明天估计要开始慢慢干活了吧 要写一个任务管理模块 王哥说今晚他把数据库和脚手架创建好 明天我可以先自己尝试了 我觉得还挺好的吧 这个实习 而且合同上面签的也是学生出去学习为主 学校有事情 提前七天告知公司就可以了 Nice！ 今天学到的东西：1.sql脚本执行 2.cmd中输ifconfig查看本机ip 3.关闭快速开机能减少运行内存的使用 附图两张： \u0026mdash;2025.10.21 实习第二天 又看了一下自己简历上面的项目 在想一下是不是还能加一下其他模块 显得比较高科技 但是现在已经有了AI聊天机器人了 一直想做个代码生成器 但是发现已经有现成的了 不知道还能加什么模块？？？ 今天中午午休的时候做力扣 链表的知识我都忘记了！这狗算法咋这么难？？？？？？？？？？？？？？？？？？？？？ 附图两张：这太阳看起来美 但是刺眼睛 果然我还是从浪漫主义变成了实用主义（doge） \u0026mdash;2025.10.22 实习第三天 拿到数据库 本来想着做一下的 但是水平还不太够 我得再摸索几天 看看公司代码都是怎么写的 应该挺好写的 比较难的业务估计也不会让我们实习生做 但是在这还是可以学到东西的。今天早上来的太早了 八点就到了 第一个到的！ 入职第三天我才知道要用飞书进行上下班打卡 等我下载好之后竟然已经八点四十了 打卡居然迟到了 真搞笑0.0 附近的车咋都长得这么帅 慕了 算法回学校再看 依旧感叹 算法好难 我现在还是摸不着套路 这算法还是得先看课吗？？ 附图两张： 小may 祝你开心\n","date":"2025-10-20T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%AE%9E%E4%B9%A0%E7%BB%8F%E5%8E%86/","title":"实习经历"},{"content":"\r参考链接： https://javaguide.cn/database/redis/redis-questions-01.html#%E4%BB%80%E4%B9%88%E6%98%AF-redis\nRedis是NoSQL数据库，是一种内存数据库。读写速度很快，经常用于分布式缓存方向，存储的是key-value对数据。Redis支持事务，持久化，lua脚本\u0026hellip;\n可以试一下在线编译器写一下redis命令 简单易上手 easy~\nRedis为什么速度快：1.纯内存操作（纳秒级），传统的数据库需要读写磁盘（毫秒级） 2.高效的I/O模型。3.优化的内部数据结构4.简洁高效的通信协议（RESP）. redis适合做缓存不适合做主数据库，因为内存成本高，且redis虽然支持数据持久化但是有数据丢失风险。 其他的分布式缓存：Tendis,KeyDB\u0026hellip;\n选择Redis的原因：1.访问速度快（基于内存） 2.高并发 3. 功能全面（可以作缓存，可以用于分布式锁，限流，消息队列，延时队列\u0026hellip;）\n常见的缓存读写策略：https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html\nRedis 应用【2025.10.20】\n缓存 分布式锁 Redission 做限流工具 Redis+LUA脚本 RRateLimiter实现分布式限流即基于Lua脚本+令牌桶算法 做消息队列 Redis的Stream类型的数据结构更适合做消息队列（但一般用中间件） 做延时队列 内置了延时队列 基于Sorted Set实现 分布式session 利用String或Hash数据结构存储session数据 Redis可以实现全文搜索引擎功能 需要借助RedisSearch（一个基于Redis的搜索引擎模块）：性能更优秀 较低内存占用实现快速索引。\n延时任务（红包过期自动退还）:实现方式：1. redis过期事件监听（不推荐） 2. redission内置的延时队列 减少了丢消息的可能，消息不存在重复消费问题\nredis常见的数据类型：String、List、Set、ZSet、Hash\n","date":"2025-10-19T00:00:00Z","permalink":"https://1parado.github.io/p/redis-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"Redis 常见面试题"},{"content":"\r基础知识（hello 算法）\nhttps://www.hello-algo.com/chapter_array_and_linkedlist/array/\n数组：数组元素存储在连续的内存空间中，如果知道数组首地址和某个元素的索引，查找数据很简单，时间复杂度低O(1)，在数组中插入和删除需要移动元素，所以时间复杂度有点高O(N)。数组（静态）的长度是不可变的（ArrayList动态数组，长度未知的数组），如果扩容数组则重新建立一个更大的数组，复制旧数组的元素到新数组中。\n1 2 // 数组初始化 int[] nums = {1,2,3} or int[] nums = new int[3]; 链表：如果数组很大 内存无法提供这么大的连续空间 则可以使用链表这种数据结构。【value,*】， *指针指向下一个节点的内存地址。链表的尾节点指向null。\n1 2 3 4 5 6 初始化链表 节点1 -\u0026gt; 节点2 // 初始化节点 n0 = listNode(1) n1 = listNode(2) // 构建节点之间的引用 n0.next = n1 链表的插入和删除很简单，只需要改变引用即可O（1），但是查询数据的时候，需要从头节点向后遍历直到目标节点O(N)。\n数组和链表采用了相反的存储策略（一个连续，一个不需要连续），因此各种性质和操作效率都呈对立特点。\n链表的种类：单向链表，双向链表，环形链表\n1 2 3 4 5 6 7 /* 双向链表节点类 */ class ListNode { int val; // 节点值 ListNode next; // 指向后继节点的引用 ListNode prev; // 指向前驱节点的引用 ListNode(int x) { val = x; } // 构造函数 } 列表：元素的有序集合，可以基于数组和链表实现。数组实现的列表是一个有长度限制的列表，因此可以用动态数组来实现列表。列表本质是数组，查找元素很快O（1），插入和删除元素O(N). 列表可以拼接。关于列表的数据结构怎么设计的可以看源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 动态数组初始化 import java.util.ArrayList; import java.util.List; List\u0026lt;Integer\u0026gt; dynamicList = new ArrayList\u0026lt;\u0026gt;(); // 空列表 dynamicList.add(1); // 添加元素 dynamicList.add(2); dynamicList.addAll(java.util.Arrays.asList(3, 4, 5)); // 批量添加 //或者 List\u0026lt;Integer\u0026gt; dynamicList2 = new ArrayList\u0026lt;\u0026gt;(10); // 初始容量 10，可自动扩容 // 列表拼接 dynamicList.add(dynamicList2); // 列表排序（进行完列表排序后 可以使用二分查找和双指针算法） Collections.sort(dynamicList2); 搜索算法：\n暴力法：通过遍历数据结构中的每个元素定位目标\n自适应搜索：利用数据的特性（比如有序性）优化搜索过程\n“二分查找”利用数据的有序性实现高效查找，仅适用于数组。时间换空间\n“哈希查找”利用哈希表将搜索数据和目标数据建立为键值对映射，从而实现查询操作。空间换时间\n数组 二分查找 二分查找是一种基于分治法策略的高效搜索算法，利用数据的有序性，每轮缩小范围直到找到目标或者找不到目标。即给指针low和high分别设置搜索目标，目标可能是一个值，也可能是一个范围，最终他们要么找到目标终止循环，要么越过边界终止循环\n二分查找的优点：时间效率高O（logN），不需要额外的空间【哈希算法以空间换时间】\n二分查找的局限性：仅适合有序数组（不要想着先对无序数组排序再用二分查找，因为排序的时间复杂度就已经很高了），不能对链表进行二分查找，不适合数据经常变化的数组。\n1.二分查找 解题思路：数组有序 返回下标（查找元素）\u0026ndash;\u0026gt; 二分法 这里采用左闭右闭区间[low,high]所以while判断的时候是low \u0026lt;= high\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int low = 0; int high = nums.length - 1; int mid = (low + high)/2; // 向下取整 // int mid = low + （high - low） 这种也可以是为了防止溢出， while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; class Solution { public int searc mid = (low + high)/2; }else{ low = mid + 1; mid = (low + high)/2; } } return -1; } } 2.二分查找插入点（无重复元素）\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n犯的问题：粗心把high初始化的时候设置成 nums. length了，2，3，4情况返回值应该是high+1（要想明白为什么是high+1 ？\u0026ndash;\u0026gt;2，3，4情况下，当循环终止时，high指向小于target的元素，low指向大于target的元素，因此插入的索引应该是high + 1）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { // 可能出现的情况四种1.找到nums[mid] = target // 2.没出现 目标值在最前面 // 3.没出现 目标值在最后面 // 4.没出现 目标值在某个区间 // 2 3 4 要保证统一返回 int low = 0; int high = nums.length - 1; int mid = (high + low)/2; while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; mid = (high + low)/2; }else{ low = mid + 1; mid = (high + low)/2; } } return high + 1; // 注意这个是力扣上的题 是找到值就返回索引 } } 二分查找插入点（有重复元素）\n给定一个长度为 的有序数组 nums 和一个元素 target ，数组存在重复元素。现将 target 插入数组 nums 中，并保持其有序性。**若数组中已存在元素 target ，则插入到其左方。**请返回插入后 target 在数组中的索引。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 二分查找插入点（存在重复元素） */ int binarySearchInsertion(int[] nums, int target) { int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1] while (i \u0026lt;= j) { int m = i + (j - i) / 2; // 计算中点索引 m if (nums[m] \u0026lt; target) { i = m + 1; // target 在区间 [m+1, j] 中 } else if (nums[m] \u0026gt; target) { j = m - 1; // target 在区间 [i, m-1] 中 } else { j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中 } } // 返回插入点 i return i; } 3.找起始位置和终止位置 没思路(老老实实写两个函数 不要想着函数复用和其他方法了 边界处理太难想了)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public int[] searchRange(int[] nums, int target) { int left = searchLeft(nums, target); int right = searchRight(nums, target); if (left != -1 \u0026amp;\u0026amp; right != -1) { return new int[]{left, right}; } return new int[]{-1, -1}; } public int searchLeft(int[] nums, int target) { int low = 0, high = nums.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (nums[mid] \u0026gt;= target) { high = mid - 1; } else { low = mid + 1; } } if (low \u0026lt; nums.length \u0026amp;\u0026amp; nums[low] == target) return low; return -1; } public int searchRight(int[] nums, int target) { int low = 0, high = nums.length - 1; while (low \u0026lt;= high) { int mid = (low + high) / 2; if (nums[mid] \u0026lt;= target) { low = mid + 1; } else { high = mid - 1; } } if (high \u0026gt;= 0 \u0026amp;\u0026amp; nums[high] == target) return high; return -1; } } 移除元素 双指针：设计不同移动速度，不同间距，不同方向的两个指针进行操作 解决问题。指向相同序列一般有快慢指针，首尾指针，固定间距指针等。指向不同序列有归并排序。可以用来求链表的中点、链表是否成环、移除数组中多余的元素（原地移除）、归并排序 等\n1.移除元素（快慢指针法）\n思路：我一想到双指针脑子里面总是会想让i指向0，j指向i+1或者就是i指向0，j指向length-1.实际上的情况比这更复杂，不能用这种惯性思维来做题。（这道题是看了代码随想录的演示动画自己写的while循环 其实for循环比这个简单）\n首先确定指针表示的含义 i是指向新的子数组的下标，新数组中不允许有val j是用于找到非val值用于交换的元素 初始化：i=j=0 在循环中i和j的变化分情况讨论 nums[i]！=val时 不需要交换 只需要i和j同时向后移动即可 nums[i]=val时 分两种情况 nums[j]=val时，需要让j自己移动到不为val的地方，变成nums[j]!=val的情况 然后进行交换 交换后i和j再同时移动 循环终止条件：当j到达length - 1 的时候循环终止\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public int removeElement(int[] nums, int val) { // i指针指向的数组中不允许有val j指针用于找到非val的元素 // 指针初始化位置 i=j=0 int i = 0; int j = 0; while(j \u0026lt;= nums.length - 1){ if(nums[i]==val){ if(nums[j]!=val){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j++; }else{ j++; } }else{ i++; j++; } } return i; } } // 第二种解法（推荐） class Solution { public int removeElement(int[] nums, int val) { int i = 0; int j = 0; while(j\u0026lt;nums.length){ if(nums[j]!=val){ // 注意这个地方的执行顺序 如果先让i++ 然后再覆盖的话就会出现溢出错误 因为这是数组 i实际是个数字不是指针不会发生指针溢出的情况 如果让数组取nums[length]才会报错 nums[i] = nums[j]; i++; } j++; } return i; } } 2.26. 删除有序数组中的重复项 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int removeDuplicates(int[] nums) { int i = 0;//slow int j = 0;//quick while(j\u0026lt;nums.length){ if(nums[i]!=nums[j]){ i++; nums[i] = nums[j]; } j++; // 这一步是每次都会执行的，并不是执行完if语句就不执行了 } return i+1; } } date: 2025-10-19\n283. 移动零 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public void moveZeroes(int[] nums) { int i=0; int j=0; while(j\u0026lt;nums.length){ if(nums[j]!=0){ nums[i] = nums[j]; i++; } j++; } //比如初始数组是【1，0，2，0，3】 结束时数组是【1，2，3，0，3】所以需要对后面的进行赋零操作 要想清楚结束的时候i指向哪 while(i\u0026lt;nums.length){ nums[i] = 0; i++; } } } 977. 有序数组的平方 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int[] sortedSquares(int[] nums) { // 首尾双指针 int i = 0; int j = nums.length-1; int k = 0; int[] nums2 = new int[nums.length]; while(i\u0026lt;=j){ if(nums[i]*nums[i] \u0026lt;= nums[j]*nums[j]){ nums2[k] = nums[i]*nums[i]; i++; }else{ nums2[k] = nums[j]*nums[j]; j--; } k++; } Arrays.sort(nums2); // 无返回值 直接对原数组进行操作 return nums2; } } 209. 长度最小的子数组 - 力扣（LeetCode）\n滑动窗口O（N）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 第一种解法 时间复杂度和空间复杂度都是O(N) 使用了滑动窗口和动态数组 可以不用动态数组而是用一个变量来记录min_length class Solution { public int minSubArrayLen(int target, int[] nums) { int i = 0; int sum = 0; ArrayList\u0026lt;Integer\u0026gt; length_list = new ArrayList\u0026lt;\u0026gt;(); // for(int j = 0;j\u0026lt; nums.length; j++){ sum += nums[j]; // 先大范围找 移动j 在满足粗略的条件之后再缩小范围 移动i【i和j都是只增不减的 双循环的时候j会变小】 while(sum \u0026gt;= target){ int length = j - i + 1; length_list.add(length); sum -= nums[i]; i++; } } if(length_list == null || length_list.isEmpty()){ return 0; }else{ int min_length = Collections.min(length_list); return min_length; } } } 59. 螺旋矩阵 II - 力扣（LeetCode）\n主要是考察边界条件的判断\n区间和: 可以用sum数组保存前n项和 如果想计算下标2-5的区间和 可以通过前5项和-前二项和\n链表 \u0026mdash;2025.10.20\n链表节点类\n1 2 3 4 5 6 7 public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } 链表删除节点 直接让next指针被删除节点的下一个节点即可 Java有自己的回收机制 被删除的节点会自动回收\n关于链表的Java语法都忘完了 删除元素就是 current.next = current.next.next; 还需要注意什么时候创建的是节点 什么时候创建的是指针\n203. 移除链表元素 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public ListNode removeElements(ListNode head, int val) { // 设置一个虚拟头节点vir 以及一个当前指针cur用来遍历 ListNode vir = new ListNode(); vir.next = head; //vir放在head前面作为虚拟头节点 ListNode cur = vir; // cur指针指向当前遍历的节点 while(cur.next!=null){ //考虑清除循环终止条件 当cur遍历到最后一个节点 即cur.next == null 时终止循环 if(cur.next.val == val){ cur.next = cur.next.next; //如果cur指向的节点值为val 则移除 }else{ cur = cur.next; // 移动cur到下一个节点 } } // 返回值难以确定时 考虑极端情况试试 // 当首节点为val时 就会被删除 所以vir.next是正确的 而不是head return vir.next; } } 707. 设计链表 - 力扣（LeetCode）\n在链表类中还需要设置链表的size 和 head 以及初始化链表 最关键的就在于如何初始化 如何循环 以及如何结束循环\n2025.10.21\n206. 反转链表 - 力扣\n反转链表（也不会 算法好难！！！\u0026ndash;果然还是安静的时候写算法题有效果）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public ListNode reverseList(ListNode head) { // 双指针 ListNode cur = head; // 当前节点指针 ListNode pre = null; // 当前节点指针的前一个节点 // （我想的太多了 我想着如果转换方向之后 后一个节点就找不到了 可以用临时temp记录一下就好了啊！） while(cur != null){ ListNode temp = cur.next; // 记录一下当前节点的下一个节点的位置 cur.next = pre; pre = cur; // 然后让pre向后移动 即指向cur cur = temp; // 让cur指向temp } return pre; } } 24. 两两交换链表中的节点 - 力扣（LeetCode）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //我想的是设置一个flag 来判断是否需要交换 然后用一个temp表示cur节点的后一个节点 用于交换 即在循环体中 1.temp = cur.next临时保存 // 2.cur.next-\u0026gt;temp.next 3. temp.next-\u0026gt;cur 但是有错误！！！ 2-1-3-5 4-3-5 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next ==null){ // 链表为空/链表中只有一个元素 return head; } // 这个代码是错误的 结果是2-1-3-5 4-3-5 ListNode cur = head; while(cur.next !=null ){ ListNode temp = cur.next; // 这是用temp记录后一个节点不行 试试用temp记录pre cur.next=temp.next; temp.next=cur; cur = cur.next; } return cur; } } 错误代码2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public ListNode swapPairs(ListNode head) { if(head == null || head.next ==null){ // 链表为空/链表中只有一个元素 return head; } ListNode vir = new ListNode(); vir.next = head; ListNode cur = head; ListNode pre = vir; while(cur.next !=null \u0026amp;\u0026amp; cur.next.next!=null){ pre.next = cur.next; cur.next = cur.next.next; pre.next.next = cur; pre = pre.next; cur = cur.next; } return vir.next; } } 正确代码：\n19 删除倒数第N个节点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 解题思路（Mine）：先找到这个节点是正数第几个位置 然后找到其前置节点 进行删除操作 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode vir = new ListNode(); vir.next = head; ListNode cur = vir; int size = 0; // 遍历一遍得到链表的size while(cur.next != null){ size++; cur = cur.next; } int z = size - n + 2; //倒数第n是正数第size - n + 1 这里的z = size - n + 1是其前节点 ListNode vir2 = new ListNode(); vir2.next = head; ListNode cur2 = vir2; int count = 1; // 要注意这里的count是从1开始的 是指链表中的第几个节点 while(cur2.next != null){ count++; if(count == z){ cur2.next = cur2.next.next; return vir2.next; } cur2 = cur2.next; } return vir2.next; } } 面试题02.07链表相交\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 第一种方法（Mine），第二种方法用双指针 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { // 需要让长链先走 然后同步移动 看是否有节点相交 int A_size = 0; // A链表的长度 int B_size = 0; // B链表的长度 ListNode A_cur = headA; ListNode B_cur = headB; if(headA == null || headB==null){ return null; } while(A_cur != null){ //在计算链表长度的时候 循环条件里面是cur 不是cur.next A_size++; A_cur = A_cur.next; } while(B_cur != null){ B_size++; B_cur = B_cur.next; } // 我想的是计算出A和B的长度差（用绝对值Math.abs(),但是这样还是区分不了哪个长哪个短） // int length = Math.abs(A_size,B_size); int length = 0; ListNode slow = null; // 指向长链表的头节点 ListNode quick = null; // 指向短链表的头节点 if(A_size - B_size \u0026gt;= 0){ length = A_size - B_size; quick = headA; slow = headB; }else{ length = -1 * (A_size - B_size); quick = headB; slow = headA; } // 将长链表的指针和短链表的指针同步 while(length \u0026gt; 0){ quick = quick.next; length--; } while(quick != null){ // 注意这里不是quick.next 如果是这样 首节点都没有比较 如果设置了虚拟节点可以是vir.next if(quick == slow){ return quick; } quick = quick.next; slow = slow.next; } return null; } } 142 环形链表ii 如何判断一个链表中是否有环？ 快慢指针 fast 每次走两步 slow 每次走一步 最终会在环内相遇 fast会追上slow 因为在环内fast相当于每次都逼近slow一个节点 难点在于如何确定哪个节点是入环点！\n【注意：链表中有些题目没有看别人优秀的题解 有些甚至都没做出来 显然下次遇到了 脑子里首先弹出来的还是自己不成熟的想法 没有形成一个自己的解题逻辑 这是不对的！应该吸收别人的思想为己所用】\nHash 表 哈希表可以快速判断一个元素是否出现在集合里 key-func（key）-value，但可能出现哈希冲突 不同的key映射到同一个value，解决方法：拉链法和线性探测法。 常见的哈希结构：数组，集合set，map。空间换时间。当遇到需要判断一个元素是否出现过 就要想到哈希法\n242.有效的字母异位词\n","date":"2025-10-17T00:00:00Z","permalink":"https://1parado.github.io/p/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/","title":"代码随想录(长期更新)"},{"content":"\r\u0026mdash;2025.10.17\n哈希 补充知识： https://javaguidepro.com/blog/hash-table-java/\n哈希表是根据key直接访问存储位置的暑假结构，key\u0026ndash;\u0026gt;hash函数\u0026ndash;\u0026gt;存储桶，每个存储桶可以存储一个或多个键值对。（哈希冲突即不同的键映射到同一个存储桶中）\n1.Hashtable 是 Java 中最早提供的哈希表实现，它是线程安全的，不允许键或值为 null\n2.HashMap 是 Java 中最常用的哈希表实现，它不是线程安全的，允许键和值为 null\n3.LinkedHashMap 是 HashMap 的子类，它维护了一个双向链表，用于记录键值对的插入顺序或访问顺序\n当需要查询一个元素是否出现过，或者一个元素是否在集合里\u0026mdash;\u0026gt;哈希法。用空间换时间，可以用数组、set、map\u0026hellip;做哈希法\n两数之和 https://leetcode.cn/problems/two-sum 题解1. 双重循环 题解2. 哈希法 Map（key，value） （我想的一个是双重循环，一个是排序比较，但是注意审题，排序之后下标都变了肯定不对！） a + b = target， 当指针指到a时，可以去map中找b是否存在。key存放值，value存放下标\n参考题解: https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.md\n代码： class Solution { public int[] twoSum(int[] nums, int target) { // 创建一个返回数组 int[] res = new int[2]; // 当传入的数组为空 直接返回[ , ] //数组为null是空引用，并没有创建这个数组对象 数组长度为0是有这个数组对象但数组元素为空 if(nums == null || nums.length == 0){ return res; } Map\u0026lt;Integer,Integer\u0026gt; indexMap = new HashMap\u0026lt;\u0026gt;(); // 遍历到某个a元素的时候，去map中找是否有满足target - a = b的b元素 有则将两者下标返回 没有则加入map // nums[i]当作key, i当作value for(int i = 0; i \u0026lt; nums.length; i++){ if(indexMap.containsKey(target - nums[i])){ res[0] = i; res[1] = indexMap.get(target - nums[i]); return res; } indexMap.put(nums[i],i); // haspMap插入key-value键值对 } return res; } }\n移动零 https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2\u0026envId=top-100-liked class Solution { public void moveZeroes(int[] nums) { int[] res = new int[]; if(nums == null || nums.length == 0){ return res; }\n}\r}\n\u0026mdash; 2025.10.22\n普通数组 53.最大子数组和\n1.我首先想的是双指针 但是最大子数组和不具备单调性，无法使用常规的“滑动窗口”技巧（即不能通过移动左右指针来收缩或扩展窗口以逼近答案）\u0026ndash;方法选用不当 不知道什么算法应该解决什么问题 2.前缀和 用数组来保存前缀和 这里又有几个坑 比如不能让fix_num += num[i] 因为fix_num中的元素初始化都为0 这相当于 fix_num = num[i]。 求前缀和可以用sum+=num[i],然后让fix_num[i] = sum; 而且要注意，不能简单的用最大前缀和-最小前缀和，要满足这个最大前缀和在最小前缀和的右边 否则不能计算。\n1 2 3 4 5 6 7 8 9 // 生成前缀和数组 int sum = 0; int[] fix = new int[nums.length]; int index = 0； for(int x : nums){ // 这里的x是数组的元素 不是下标 sum += x; fix[index] = sum; index++； } 最大区间和 = fix[j] - fix[i-1]，其中 i \u0026lt;= j 要使这个差值最大，就要让 fix[j] 尽可能大，fix[i-1] 尽可能小，且 i-1 \u0026lt; j.【为什么是减去fix[i-1]???】 3.动态规划DP\n二分查找 力扣35 搜索插入位置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int searchInsert(int[] nums, int target) { // 可能出现的情况四种1.找到nums[mid] = target // 2.没出现 目标值在最前面 // 3.没出现 目标值在最后面 // 4.没出现 目标值在某个区间 // 2 3 4 要保证统一返回 int low = 0; int high = nums.length - 1; int mid = (high + low)/2; while(low \u0026lt;= high){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ high = mid - 1; mid = (high + low)/2; }else{ low = mid + 1; mid = (high + low)/2; } } return high + 1; } } 74.搜索二维矩阵\n我的想法就是将二维矩阵变成一维数组 然后再使用二分查找 因为这个题目中的数组都是m行n列的。别人的题解说可以用两次二分查找，之后记得看看！\n1.如何遍历二维数组并将其转换为一维数组？\n1 2 3 4 5 6 7 8 9 10 11 int m = matrix.length; // 行数 int n = matrix[0].length; // 第一行的列数 matrix[i].length表示第i行的列数 int[] nums = new int[m*n]; int index = 0; for(int i = 0;i\u0026lt;m;i++){ for(int j = 0;j\u0026lt;n;j++){ nums[index] = matrix[i][j]; index++; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 完整代码 class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length; // 行数 int n = matrix[0].length; // 第一行的列数 int[] nums = new int[m*n]; int index = 0; boolean flag = false; for(int i = 0;i\u0026lt;m;i++){ for(int j = 0;j\u0026lt;n;j++){ nums[index] = matrix[i][j]; index++; } } int i = 0; int j = nums.length - 1; while( i \u0026lt;= j){ int mid = i + (j-i)/2; if(target \u0026gt; nums[mid]){ i = mid+1; }else if(target \u0026lt; nums[mid]){ j = mid -1; }else{ flag = true; return flag; } } return flag; } } 34. 在排序数组中查找元素的第一个和最后一个位置\n寻找左边界（不含target）和右边界（不含target） 主要还是要考虑清楚返回值是什么 要考虑target 存在和不存在的情况？？？？\n33. 搜索旋转排序数组\n我想的是让这个旋转后的数组变成一个有序数组 然后进行二分查找 找到target 即新建一个数组存放原始未旋转的数组 然后找到在这个数组中target的下标 再去求旋转后数组的下标 但是有个问题 找旋转点的过程需要遍历整个数组O(N)\n为什么情况是这么多种？？？？ 1.二分后，左边的数组是升序的(nums[0]\u0026lt;nums[mid]) 1.1 target\u0026gt;nums[mid]：应该往右边搜索 1.2 target\u0026lt;nums[mid]并且target\u0026lt;nums[0]：应该往右边搜索 1.3 target\u0026lt;nums[mid]并且target\u0026gt;=nums[0]：应该往左边搜索\n2.二分后，左边的数组是存在翻转点的(nums[0]\u0026gt;nums[mid]) 2.1 target\u0026lt;nums[mid]并且target\u0026gt;=nums[0]：应该往左边搜索 2.2 target\u0026lt;nums[mid]并且target\u0026lt;nums[0]：应该往左边搜索 2.3 target\u0026gt;nums[mid]并且target\u0026lt;nums[0]：应该往右边搜索 2.4 target\u0026gt;nums[mid]并且target\u0026gt;=nums[0]：应该往左边搜索\n完成情况：（左右边界那题也不熟悉） ","date":"2025-10-17T00:00:00Z","permalink":"https://1parado.github.io/p/%E5%8A%9B%E6%89%A3hot100/","title":"力扣hot100"},{"content":"\rRuoYi-Vue-Pro: https://doc.iocoder.cn/quick-start/\n后端版本:我下载的mini版本的，只有一些简单的功能，其中的一些功能是受限的 https://github.com/YunaiV/ruoyi-vue-pro\n前端版本：Vue3 + element-plus 版本 https://github.com/yudaocode/yudao-ui-admin-vue3/\n按照RuoYi配置文档一步一步来其实挺好搭建的，主要是要先配置环境。\n","date":"2025-10-16T00:00:00Z","permalink":"https://1parado.github.io/p/ruoyi%E6%A1%86%E6%9E%B6/","title":"RuoYi框架"},{"content":"\r⚫ 找论文的一些网站（有些网站要翻墙） Google scholar⭐⭐⭐⭐⭐： 可以配合谷歌插件Easy scholar直接显示期刊的等级和影响因子 2.Web of science⭐⭐⭐\n3.Sciencedirect⭐⭐⭐\n4.Ieeexplore⭐⭐⭐\n5.Arxiv⭐⭐预印的期刊，文章比较新但可能有小错误\n6.CNKI 中文知网⭐⭐\n⚫ 文献管理工具： Zotero + 翻译插件: https://blog.csdn.net/xiaoningaijishu/article/details/151042814\nIma腾讯推出的个人知识库（英文不好的强烈推荐！）把论文上传到知识库中，然后全局翻译，翻译的很准确，而且可以根据知识库进行提问。\n小绿鲸（我没用过，看师兄用过）: https://www.xljsci.com/\n⚫ 笔记软件： Notion，Obsidian，Ima，Typora, Cherry studio\u0026hellip;推荐Obisidian 轻量化（但其实没有做笔记的习惯的话不下载也可以）\n⚫ 用于论文写作的一些工具 overleaf是一款在线编写latex格式的论文写作软件，可以配合浏览器插件Grammarly检查语法错误 https://app.grammarly.com/\noverleaf模板: https://cn.overleaf.com/latex/templates 点 Journal Article 找对应的论文模板格式下载压缩包 导入到overleaf即可编写操作\n习惯用Vs code的可以在vscode中下载overleaf的插件 直接在vscode中编写也可:https://zhuanlan.zhihu.com/p/29808221714\n⚫ 好用的网站： 表转latex格式 https://tablesgenerator.com/\nlatex公式在线编写： https://www.latexlive.com/home\nCanva做汇报ppt: https://www.canva.cn/\nBoardmix做思维导图: https://boardmix.cn/app/home\nProcesson做流程图: https://www.processon.com/\nVison也可以画流程图，可以导出矢量图.svg格式，适合放在文章里面做流程图:https://blog.csdn.net/laowangpython/article/details/147465427\n⚫ AI工具： 我常用的ai就是下面这些，主推GPT和Grok，其他的可以在论文写作的时候，优化论文表达的时候用。【小技巧：可以自己写中文初稿，然后让gpt翻译成英文，再截图让gpt生成latex格式，直接复制到overleaf里即可，英文好的话直接用英文写也可以】\n1.chatgpt: https://chatgpt.com/\n2.grok: https://grok.com/\n3.kimi: https://www.kimi.com/\n4.deepseek: https://chat.deepseek.com/\n每个课题组的研究方向不一样，发论文的难度也不一样，下面只是我的研究过程： 先确定研究方向，然后读最新的几篇综述（最好选英文文献，中文也可以），然后找一篇感觉能复现出来的文章进行复现（可以发邮件给作者看看能不能要到源码，最好多问几个，真的有人愿意给的/用AI帮忙），然后在该文章的基础上想一下有没有可以新增的点（看论文的未来展望/和其他论文模型进行融合），一篇好的论文需要天时地利人和，EI会议随便写，好多都是论文A的模块 + 论文B的模块整合到一起得到自己的创新模型。\n以我们组的研究方向为例：网络弹性量化（Cyber resilience quantification），在文献搜索网站上面搜关键词，然后读几篇综述，大致了解一下网络弹性评估包括车联网，信息关键基础设施网络，电网，无人机集群网络\u0026hellip;.本来是研究车联网的，然后组会汇报两次无人机相关文章，莫名其妙研究方向变成无人机了，也算找到了研究领域:无人机集群网络弹性评估。然后读无人机集群网络弹性评估的文章，暑假开始，老师让复现文章，刚开始一直没复现出来，联系好多文章作者要源码，最后有一个学长给了我他的部分代码，然后复现他的这篇文章，在他的文章基础上加了一些模块解决了一些现有研究领域没有解决的问题。（文章还没发，不敢把论文放网上）满打满算两个多月写一篇EI是够用的。\n","date":"2025-10-16T00:00:00Z","permalink":"https://1parado.github.io/p/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/","title":"科研论文写作"},{"content":"\r参考链接：https://javaguide.cn/database/mysql/mysql-questions-01.html\n📚 数据库基础 ER图 提供实体（方块） 属性（椭圆）和联系（菱形）的方法 关系：1对1，1对多，多对多\u0026hellip; 在创建项目之前应该先构建好数据库 并且绘制ER图来理清数据之间的关系。\n数据库范式：1NF（属性不可再分）,2NF（在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖）,3NF（在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖），BCNF（在3NF的基础上 去除属性见不必要的函数依赖）\n主键：唯一标识一个元组（行）不重复不为空，一个表只有一个主键\n外键：与其他表建立联系 外键是另外一个表的主键 可以重复可以为空 一个表可以有多个外键\n一般不推荐外键：1.增加了复杂性 2.增加了维护外键的工作量 3.对数据库分表不友好\n外键的好处：1.保证数据一致性和完整性 2.级联操作简单\ndrop 删除表结构 turncate 清空表数据 delete使用where限定删除某一行数据/清空表数据\n执行速度drop\u0026gt; turncate \u0026gt;delete\n数据库设计：需求分析-ER图-ER图转为表-选取数据库和存储结构-编程测试试和运行-运行和维护\n关系型数据库:如 mysql 支持事务的四大属性：ACID属性（原子性，一致性，隔离性，持久性）\n非关系型数据库: 如redis 天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。非关系型数据库比较灵活，性能高，可扩展性强\n字符集：GBK,ASCII,UTF8\u0026hellip; MySQL8.0默认字符集utf8mb4\nDDL数据定义语言: 定义数据库对象 CREATE、ALTER、DROP\nDML数据操纵语言 : 访问数据，因此其语法都是以读写数据库为主 CRUD\nDCL数据控制语言 : 控制用户的访问权限 授予权限GRANT、收回权限REVOKE\nTCL事务控制语言：管理数据库中的事务 , 提交事务commit 回滚事务 rollback\n索引⭐【面试被问到了】\n索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构\n分为：唯一索引 主键索引 聚集索引 哈希索引\nhttps://javaguide.cn/database/mysql/mysql-index.html\nsql（结构化查询语言） 语法常见面试总结可以去牛客上看 也可以刷力扣上的sql 题 这里我就不着重看了 之后刷sql题的时候再看\n容易混淆的点：\nDecimal 可以存精确的小数 Float / Double 只能存近似的小数 DateTime 没有时区信息 八字节存储 TimeStamp 和时区有关 四字节存储 Null 1.null表示缺失的值 2.任何值与null比较结果都是null 3.有些聚合函数忽略null “ ” 1.空字符串 2.“ ” 可以进行比较，如 “ ” = “ ”结果为true 3. 聚合函数不忽略 MySQL执行流程：\n连接器（进行身份验证） 分析器（进行词法分析 和 语法分析） 优化器（按照MySQL认为最优的方案执行） 执行器（执行语句 从存储引擎返回数据） **存储引擎⭐（InnoDB、MyISAM、Memory 等多种存储引擎。InnoDB 是 MySQL 的默认存储引擎，只有InnoDB支持事务） 存储引擎采用插件式架构 ，基于表结构而不是数据库\nMySQL 日志⭐\n常见的日志分类:错误日志，查询日志，慢查询日志（可以结合 EXPLAIN 分析查询执行计划，优化索引或 SQL 结构，可用于性能优化），二进制日志（主从复制），回滚日志，重做日志（保证事务的持久性）\u0026hellip;\nMySQL事务：逻辑上的一组操作要么都执行要么都不执行。事务分为扁平事务（最简单的情况），嵌套事务，分布式事务\u0026hellip; 事务的四大属性ACID. 事务的目的就是为了保证数据的一致性。\n并发事务带来的问题：脏读，不可重复读，幻读，丢失修改（四种问题基本概念是什么？如何解决？）\n并发事务的控制方式：\n锁，通过读写锁来显式控制共享资源 分为表级锁（对整表加的锁）和行级锁（对索引字段加的锁），MyISAM 仅仅支持表级锁，InnoDB两者均支持。无论是表级锁和行级锁都存在共享锁S和排他锁X。意向锁可以来快速判断是否可以对某个表使用表锁，从而有了意向共享锁IS和意向排他锁IX MVCC（多版本并发控制）即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。 事务隔离级别（级别越高，数据一致性越好，但并发性能可能越低）：1.读未提交 2.读已提交 3.可重复读（MySQL默认的隔离级别） 4.可串行化。 MySQL 的隔离级别基于锁和 MVCC 机制共同实现的\n当前读和快照读\n当前读 = 当前最新数据 + 会加锁 → “最新、可能被阻塞”\n快照读 = 事务快照 + 不加锁 → “旧版本、不会被阻塞”\nMySQL调优⭐\nhttps://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html\nMySQL可以存文件（文件转为二进制文件存入MySQL），但是影响数据库性能占用太多存储空间。可以用云服务厂商提供的对象存储如OSS\u0026hellip;也可以用MinIO开源项目实习分布式文件服务。\nhttps://www.51cto.com/article/716978.html\nMySQL性能优化：慢查询日志找 SQL → Explain 看执行计划（分析性能） → 索引优化/表结构优化\u0026hellip; → 锁和 IO 分析 → SQL 重写 → 测试验证\n读写分离：读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。\n如何实现：主数据库和从数据库数据实时同步（主从复制），写请求交给主数据库处理，读数据库交给从数据库处理。\n主从复制：主数据库的数据变化写入二进制日志，从库链接主库，主库创建I/O线程发送二进制日志给从库，从库将二进制日志写入中继日志（Relay log）然后从库的sql线程读取中继日志实现主从数据实时同步（可能会发生主从同步延迟）\n第一种实现方式：代理方式\n在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。\n第二种实现方式：组件方式\n引入第三方组件来帮助我们读写请求。\n分库分表：如果一张表的存储数据量太大就要分库分表。分库分为水平分库（按照数据划分，行划分）和垂直分库（按照业务划分，属性划分）分表与分库同理。分库分表之后需要解决事务问题，分布式id问题，join操作问题\n冷热数据：热数据是指经常被访问和修改且需要快速访问的数据，冷数据是指不经常访问，对当前项目价值较低，但需要长期保存的数据。可以按照时间和访问频率划分。\n延时双删⭐【面试被问到了】（保证数据一致性）：首先删除redis中的缓存数据，然后更新数据库中的数据，让当前线程休眠一段时间，唤醒之后再次删除redis的缓存数据。\n2025.10.19\nMySQL高性能优化规范建议总结（了解即可） 数据库命名要规范 所有表使用InnooDB存储引擎 数据库和表的字符集统一使用utf8 单个表的数据量大小尽量在500万之内，再大可以考虑分库分表。对于日期类型用Datatime或timestamp 不要用字符串存储。可以通过查询MySQL的慢查询日志发现需要进行优化的sql语句。对于超100万行的批量操作（插入，更新，删除）要分批多次进行操作，因为大批量操作可能会造成主从延迟。\n重点【重新看一下】 索引：索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。常见的索引结构：B-Tree索引、B+树索引、Hash索引、红黑树索引\u0026hellip; InnoDB和MyISAM都选择B+树作为索引结构. 索引的优缺点：\n优点：1.查询速度快减少磁盘I/O次数 2.保证数据的一致性（唯一索引）3.可以加快排序和分组\n缺点：创建和维护耗时，占用存储空间,当数据量太小的时候全表扫描速度会比索引快。\n索引： 1.按照数据结构分类：B-Tree索引、B+树索引、Hash索引、红黑树索引\u0026hellip; 2.按照底层存储方式分类：聚集索引和非聚集索引 3.应用维度分类：主键索引，唯一索引，普通索引，覆盖索引\nB数和B+树的区别：1. B树的每个节点都存了key和data，B+树的data只存在叶子节点。非叶子节点仅存在key，可以让B+树更低，磁盘I/O操作次数更少。2. B+树所有叶子构成有序链表按照主键排序遍历全部记录 支持范围查找。\n主键索引：一个表只有一个主键索引，主键索引不能为null，不能重复。如果设计表的时候没有符合的字段（唯一且不为null），InnoDB会自动创建一个自增字段作为主键索引。\nEXPLAIN 分析执行计划 通过查询优化器对语句进行分析 找出最优的查询方法 并显示对应的信息\nMySQL三大日志：\n二进制日志（Binary log）：记录了所有对数据库的DDL和DML操作。可以用于数据备份，主从复制 ","date":"2025-10-15T00:00:00Z","permalink":"https://1parado.github.io/p/mysql-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","title":"Mysql 常见面试题"},{"content":"\r2025.10.15 这是创建的 思维导图\n2025.10.21\n登录模块 登录鉴权 ：该项目采用SpringAOP + 自定义注解@RoleRequire实现RBAC鉴权\n现有的登录鉴权方式：\nSpringSecurity+RBAC模型+JWT实现认证与授权 SpringBoot + Sa-Token + MyBatis + MySQL + Redis 实现用户鉴权、角色管理、权限管理 Apache Shiro 是一个轻量级的安全框架，适合需要简单易用的权限管理的项目 自定义 定义用户、角色、权限三张表，设计合理的关联关系， 使用拦截器或 AOP 实现权限校验逻辑。根据业务需求设计动态权限分配机制。 JWT实现无状态认证（不需要服务器存储用户的会话状态），一个JWT包括头部，载荷，签名。\n过程：用户登录认证时，服务端验证用户身份，成功的话，服务端生成JWT返回给客户端，客户端在之后的请求中将JWT放在请求的头部（Authorization）,然后服务端通过解析JWT从而确定用户的身份和权限\n双token机制实现无感刷新：分为两种token 一种是access token（访问令牌）短期有效 ，一种是 refresh token（刷新令牌），长期有效。\n过程：客户端登录，认证成功，服务端签发access_token（返回给前端）和refresh token（存入cookie） 之后，客户端访问接口都带着access_token 当access_token过期之后 客户端发送给refresh token给服务端 验证通过则生成新的access token和refresh token，从而实现无感刷新\n双 Token 认证机制：从原理到实践的完整实现双 Token 认证机制：从原理到实践的完整实现 在现代 Web 应用中 - 掘金\n登录模块展示：首先进入登录页面： 然后根据角色的不同，进入不同的主页，系统分为三种角色Admin,Teacher,Student 秒杀抢课模块 1.获取动态路径 使用UUID + MD5生成一个唯一标识符 结合前端URL生成动态路径 避免被脚本直接访问\n2.实现限流保护 使用令牌桶实现限流保护（ Redis + 令牌桶算法），这里创建一个工具类TokenBucket，里面的参数包括桶的最大容量，间隔几秒补充几个令牌，当前可用令牌数\u0026hellip;方法包括令牌补充refill和获取令牌逻辑try Acquire 从而实现限流。\n还可以利用redission实现分布式限流 基于 Redisson 的分布式限流实战：令牌桶算法的优雅实现 - 你小志蒸不戳 - 博客园，比如保护AI访问的API\n其他限流方式：固定窗口、滑动窗口、漏桶限流和令牌桶限流算法\n检验动态路径（在获取动态path的时候会将动态path存入Redis，用于此时的动态路径校验） 检查当前用户是否重复秒杀 (幂等控制) 通过三级缓存实现 本地缓存采用Caffine/Guava 二级缓存采用Redis 三级缓存采用数据库 当发现任意一级的数据库中已经有选课记录了 就返回重复秒杀异常 幂等性指的是一个操作，无论执行多少次，都能得到相同的结果，即它不会因为执行多次而影响系统的状态。这在处理网络请求、数据库操作等场景中尤为重要，例如在订单支付、消息推送等操作中，即使因为网络延迟或其他原因导致多次请求，也应保证操作只执行一次，避免重复处理。\n进入秒杀的核心阶段 Redis + Lua脚本 + RocketMQ 实现 库存预减 + 异步入队\n从零开始实现秒杀系统（三）：RocketMQ消息队列篇 - Xun\u0026rsquo;s Blog\nLua脚本进行双重判断，首先判断是否售罄标志，然后再判断库存预减之后的库存数量，并且在脚本中实现库存减1的操作 如果成功返回1 失败返回 0.Lua脚本返回成功，系统发送消息到消息队列（RocketMQ）采用事务消息机制保证数据的最终一致性。\n生产者发送半消息 本地事务创建选课记录（订单） 根据事务的执行结果通知Broker是投递该消息还是丢弃该消息 消费者异步从MQ中消费信息 完成后续业务。\n页面展示： 首先填写预选课信息（类似于商城系统的购物车），然后查看选课信息（普通选课和秒杀抢课） 如果用户是首次抢课且库存充足，则显示抢课成功 如果用户重复抢课则提醒请勿重复秒杀 Admin端新增抢课信息 当学生张三选过课程之后，该课程已经“售罄”了 接下来用李四来选课会提醒库存不足 抢课失败 之后可以考虑用jmeter测试高并发场景下的抢课情况。\n支付模块 支付过程：\n用户点击缴费 进入AliPayController 用请求头中的Authorization进行身份验证 用请求体中的PaymentPO来生成缴费信息【前端会收集页面信息 当用户点击缴费按钮就会构建PaymentPO写入请求体中传给后端】 初始化订单信息 订单的状态初始化为0 标识未缴费 每个订单有一个唯一的订单号 使用创建好的支付工具类PayUtil 调用支付宝接口完成支付流程\nPayUtil中的核心方法即发起支付和查询支付结果方法： 发起支付：1.初始化支付宝客户端 2. 创建支付请求 3.设置业务参数 4.发起请求并且返回支付结果 查询支付结果：创建查询请求-执行查询-处理查询结果\n结果展示： 学生点击缴费之后，跳转到支付页面 GitHub上面有一些支付服务的项目： https://github.com/search?q=%E6%94%AF%E4%BB%98\u0026ref=opensearch\u0026type=repositories 可以支持支付服务的快速开发。\nAI选课助手模块 chatClient介绍：https://springdoc.cn/spring-ai/api/chatclient.html\n请求接收与路由：用户通过Vue3前端界面提出问题，后端RESTful API接收请求。核心的智能路由逻辑会根据预设关键词（如“选课”、“推荐”、“统计”等）判断问题类型。\n业务上下文构建：对于选课相关问题，系统会调用 CourseSelectionService ，通过 JdbcTemplate 高效查询选课数据库，获取课程热度、名额、个人成绩倾向等实时统计数据。\nPrompt工程与模型调用：将查询到的业务数据作为上下文，与预先设计好的系统Prompt（如“你是一名选课顾问…”）进行组装，形成完整的提示信息，然后通过Spring AI调用本地的Ollama (Qwen2:7b)模型。\n响应返回：模型生成的个性化建议或通用回答最终通过统一的API返回给前端展示。\n我总觉得代码生成器（Mybatis-Plus，RuoYi代码生成器）的实现方式和这也差不多 首先创建模板（这里是提示词）然后查询表结构数据，再进行模板渲染得到生成的代码\n过程：请求流程：chatClient.call(message) → 调用 OllamaChatClient → 向本地 Ollama 服务发送请求 智能路由：isCourseSelectionQuestion 方法实现业务问题识别，将选课相关问题路由到 BusinessAIService\nchatClient是SpringAi提供的聊天 页面展示： 2025.10.22\n论坛模块 对于论坛模块，学生可以发帖评价课程，教师不能发帖，两者都可以进行评论回复交流 论坛主页展示一些帖子和热门榜单（Redis缓存）【这都是些简单的增删改查】 想到了一个小玩意，在用户进行发布帖子和进行评论的时候，进行敏感词检查。如果内容中包含敏感词 就弹出提示。实现起来挺简单的，让Java后端负责业务逻辑，python负责机器学习，python运行在本地端口，两者通过http进行通信。 详情请看这篇文章 如何实现一个简单的敏感词检测\n","date":"2025-10-15T00:00:00Z","permalink":"https://1parado.github.io/p/%E4%BB%BF%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F/","title":"仿教务系统"},{"content":"\r记录一下创建个人博客的过程。欢迎阅读！\n用到的工具：Github Page + Hugo\n参考链接： https://bright9911.github.io/\n","date":"2025-10-14T00:00:00Z","permalink":"https://1parado.github.io/p/github-page--hugo-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%93%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","title":"GitHub page + hugo 搭建一个专属于自己的个人博客"}]